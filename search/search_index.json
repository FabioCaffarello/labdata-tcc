{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Welcome to the LabData TCC project! This project is part of my final work for the master's program in Data Engineering at FIA Business School. The aim of this project is to build an event-driven architecture (EDA) using configuration-oriented microservices for downloading videos from YouTube . These downloads will be used to create a knowledge graph using large language models (LLMs), enabling semantic queries through prompts as a chat chain. This repository is a monorepo, containing multiple packages and services that work together to achieve the project's goals.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Depending on how you choose to run the project, the requirements may vary. Please ensure you have met the following requirements based on your preferred method:</p> <ol> <li> <p>Running Locally</p> </li> <li> <p>You have installed:</p> <ul> <li>Python 3.10</li> <li>Poetry <pre><code>pip install poetry==1.8.3\n</code></pre></li> <li>Golang 1.22.x</li> <li>Wire <pre><code>go install github.com/google/wire/cmd/wire@latest \n</code></pre></li> <li>gomarkdoc <pre><code>go install github.com/princjef/gomarkdoc/cmd/gomarkdoc@latest\n</code></pre></li> <li>Node.js 22.x</li> <li>docker 26.1.1</li> </ul> </li> <li> <p>Running in a Devcontainer Locally</p> </li> <li> <p>You have installed:</p> <ul> <li>Docker</li> <li>Visual Studio Code with the Remote - Containers extension</li> </ul> </li> <li> <p>Running in GitHub Codespaces</p> </li> <li> <p>You have a GitHub account with access to GitHub Codespaces.</p> </li> </ol>"},{"location":"#installation","title":"Installation","text":"<ol> <li>Clone the Repository</li> </ol> <p>First, clone the repository to your local machine using git:</p> <pre><code>git clone https://github.com/FabioCaffarello/labdata-tcc.git\ncd labdata-tcc\n</code></pre>"},{"location":"#running-the-project","title":"Running the Project","text":"<ol> <li> <p>Running Locally</p> </li> <li> <p>Set Up the Environment</p> <p>Ensure you have all the required dependencies:</p> <ul> <li> <p>NodeJS:     <pre><code>npm install\n</code></pre></p> </li> <li> <p>Python:     <pre><code>poetry install\n</code></pre></p> </li> </ul> </li> <li> <p>Running in a Devcontainer Locally</p> </li> </ol> <p>Ensure you have Docker and Visual Studio Code installed with the Remote - Containers extension. Open the repository in Visual Studio Code and click on \"Reopen in Container\" when prompted. The environment will be set up automatically.</p> <ol> <li>Running in GitHub Codespaces</li> </ol> <p>You can also run the project in GitHub Codespaces directly. Navigate to the repository on GitHub, click the \"Code\" button, and select \"Open with Codespaces\" to create a new codespace. The environment will be set up automatically.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please read the CONTRIBUTING.md file for details on the process for submitting pull requests.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#contact","title":"Contact","text":"<p>If you have any questions or need further assistance, feel free to contact me at linkedin or open an issue on GitHub.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to LabData TCC","text":"<p>Thank you for your interest in contributing to the labdata-tcc project! I welcome contributions from the community and am excited to see what you'll bring to the project. This document outlines the guidelines for contributing to the project.</p>"},{"location":"CONTRIBUTING/#getting-started","title":"Getting Started","text":""},{"location":"CONTRIBUTING/#fork-the-repository","title":"Fork the Repository","text":"<ol> <li>Fork the repository by clicking the \"Fork\" button on the top right of the repository page.</li> <li>Clone your fork to your local machine:</li> </ol> <pre><code>git clone https://github.com/&lt;your-username&gt;/labdata-tcc.git\ncd labdata-tcc\n</code></pre> <ol> <li>Add the upstream repository:</li> </ol> <pre><code>git remote add upstream https://github.com/FabioCaffarello/labdata-tcc.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-the-development-environment","title":"Setting Up the Development Environment","text":"<ol> <li> <p>Running Locally</p> </li> <li> <p>Prerequisites</p> <p>Ensure you have the required software installed:  - Python 3.10    - Poetry <pre><code>pip install poetry==1.8.3\n</code></pre>  - Golang 1.22.x    - Wire <pre><code>go install github.com/google/wire/cmd/wire@latest \n</code></pre>    - gomarkdoc <pre><code>go install github.com/princjef/gomarkdoc/cmd/gomarkdoc@latest\n</code></pre>  - Node.js 22.x  - Docker 26.1.1</p> </li> <li> <p>Set Up the Environment</p> <ul> <li> <p>Install NodeJS dependencies:    <pre><code>npm install\n</code></pre></p> </li> <li> <p>Install Python dependencies:    <pre><code>poetry install\n</code></pre></p> </li> </ul> </li> <li> <p>Running in a Devcontainer Locally</p> </li> </ol> <p>Ensure you have Docker and Visual Studio Code installed with the Remote - Containers extension. Open the repository in Visual Studio Code and click on \"Reopen in Container\" when prompted. The environment will be set up automatically.</p> <ol> <li>Running in GitHub Codespaces</li> </ol> <p>You can also run the project in GitHub Codespaces directly. Navigate to the repository on GitHub, click the \"Code\" button, and select \"Open with Codespaces\" to create a new codespace. The environment will be set up automatically.</p> <ul> <li> <p>Set Up Husky</p> <p>If you choose to run the project locally, you must set up Husky for managing Git hooks:</p> <pre><code>npm prepare\n</code></pre> </li> </ul>"},{"location":"CONTRIBUTING/#commit-message-linting","title":"Commit Message Linting","text":"<p>I use commit message linting to maintain a consistent commit history. Please follow the commit message format:</p> <pre><code>git commit -m \"type(scope): Description of your changes\"\n</code></pre> <p>For example:</p> <pre><code>git commit -m \"feat(api): Add new endpoint for data retrieval\"\n</code></pre> <p>The available types are: - <code>feat</code>: A new feature - <code>fix</code>: A bug fix - <code>docs</code>: Documentation only changes - <code>style</code>: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) - <code>refactor</code>: A code change that neither fixes a bug nor adds a feature - <code>perf</code>: A code change that improves performance - <code>test</code>: Adding missing or correcting existing tests - <code>chore</code>: Changes to the build process or auxiliary tools and libraries such as documentation generation</p>"},{"location":"CONTRIBUTING/#making-changes","title":"Making Changes","text":"<ol> <li>Create a Branch</li> </ol> <p>Create a new branch for your feature or bugfix:</p> <pre><code>git checkout -b &lt;branch-name&gt;\n</code></pre> <ol> <li>Make Your Changes</li> </ol> <p>Implement your changes. Ensure your code follows the project's coding standards and includes appropriate tests.</p> <ol> <li>Commit Your Changes</li> </ol> <p>Commit your changes with a clear and descriptive commit message following the commit message linting guidelines:</p> <pre><code>git add .\ngit commit -m \"type(scope): Description of your changes\"\n</code></pre> <ol> <li>Push Your Changes</li> </ol> <p>Push your changes to your forked repository:</p> <pre><code>git push origin &lt;branch-name&gt;\n</code></pre> <ol> <li>Submit a Pull Request</li> </ol> <p>Go to the original repository on GitHub and open a pull request. Provide a detailed description of your changes and any additional context that may be helpful for the reviewers.</p>"},{"location":"CONTRIBUTING/#code-style","title":"Code Style","text":"<ul> <li>Follow the coding style guidelines and best practices for Python, Go, and JavaScript.</li> <li>Use descriptive variable and function names.</li> <li>Write clear and concise comments where necessary.</li> <li>Use Docstrings:</li> <li>For Python, follow the Google Python Style Guide</li> <li>For Go, use GoDoc style for documentation.</li> <li>For JavaScript, use JSDoc style for documentation.</li> <li>Update README Files:</li> <li>Ensure that you update the README files in relevant directories to reflect any changes you make to the code or documentation.</li> <li>Provide clear instructions and examples where necessary to help others understand and use the code.</li> </ul>"},{"location":"CONTRIBUTING/#running-tests","title":"Running Tests","text":"<p>Ensure that all tests pass before submitting your pull request. You can run the tests using the following commands:</p> <ul> <li>Run tests for a specific project:   <pre><code>make check project=&lt;project-name&gt;\n</code></pre></li> </ul> <p>If you are unsure about the project name, you can check it in the <code>project.json</code> file of the respective project.</p> <ul> <li>Run all tests:   <pre><code>make check-all\n</code></pre></li> </ul>"},{"location":"CONTRIBUTING/#reporting-issues","title":"Reporting Issues","text":"<p>If you encounter any issues or have suggestions for improvements, please open an issue on GitHub. Provide as much detail as possible to help us understand and address the issue.</p>"},{"location":"CONTRIBUTING/#license","title":"License","text":"<p>By contributing to LabData TCC, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"CONTRIBUTING/#thank-you","title":"Thank You!","text":"<p>Thank you for your contributions to labdata-tcc! Your efforts help make this project better for everyone. If you have any questions or need further assistance, feel free to contact us at LinkedIn or open an issue on GitHub.</p>"},{"location":"summary/","title":"Summary","text":"<ul> <li>Architecture</li> <li>Services</li> <li>Libraries</li> <li>Dependency Graph</li> </ul>"},{"location":"reference/libs/golang/clients/resources/go-minio/","title":"go-minio","text":"<p><code>go-minio</code> is a Go library that provides a convenient interface for interacting with Minio, an object storage server compatible with Amazon S3 cloud storage service. This library wraps the Minio client to offer additional functionality and simplifies operations such as uploading, downloading, and managing objects in Minio.</p>"},{"location":"reference/libs/golang/clients/resources/go-minio/#features","title":"Features","text":"<ul> <li>Create a new Minio client with configuration options.</li> <li>Upload files to a Minio bucket.</li> <li>Upload files in chunks to handle large files.</li> <li>Download files from a Minio bucket.</li> <li>Remove objects from a Minio bucket.</li> <li>Remove all objects from a Minio bucket.</li> </ul>"},{"location":"reference/libs/golang/clients/resources/go-minio/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/clients/resources/go-minio/#creating-a-client","title":"Creating a Client","text":"<pre><code>package main\n\nimport (\n    \"log\"\n    \"libs/golang/clients/resources/go-minio/client\"\n)\n\nfunc main() {\n    config := gominio.Config{\n        Endpoint:  \"localhost:9000\",\n        AccessKey: \"minioaccesskey\",\n        SecretKey: \"miniosecretkey\",\n        UseSSL:    false,\n    }\n    client, err := gominio.NewClient(config)\n    if err != nil {\n        log.Fatal(err)\n    }\n    // Use the client...\n}\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-minio/#uploading-a-file","title":"Uploading a File","text":"<pre><code>package main\n\nimport (\n    \"log\"\n    \"libs/golang/clients/resources/go-minio/client\"\n)\n\nfunc main() {\n    config := gominio.Config{\n        Endpoint:  \"localhost:9000\",\n        AccessKey: \"minioaccesskey\",\n        SecretKey: \"miniosecretkey\",\n        UseSSL:    false,\n    }\n    client, err := gominio.NewClient(config)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fileContent := []byte(\"Hello, Minio!\")\n    bucketName := \"example-bucket\"\n    fileName := \"hello.txt\"\n    uploadedPath, err := client.UploadFile(bucketName, fileName, fileContent)\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Println(\"File uploaded to:\", uploadedPath)\n}\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-minio/#uploading-a-file-with-chunks","title":"Uploading a File with Chunks","text":"<pre><code>package main\n\nimport (\n    \"log\"\n    \"libs/golang/clients/resources/go-minio/client\"\n)\n\nfunc main() {\n    config := gominio.Config{\n        Endpoint:  \"localhost:9000\",\n        AccessKey: \"minioaccesskey\",\n        SecretKey: \"miniosecretkey\",\n        UseSSL:    false,\n    }\n    client, err := gominio.NewClient(config)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fileContent := make([]byte, 150*1024*1024) // 150MB\n    bucketName := \"example-bucket\"\n    fileName := \"largefile.txt\"\n    partSize := int64(50 * 1024 * 1024) // 50MB\n    uploadedPath, err := client.UploadFileWithChunks(bucketName, fileName, fileContent, partSize)\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Println(\"File uploaded in chunks to:\", uploadedPath)\n}\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-minio/#downloading-a-file","title":"Downloading a File","text":"<pre><code>package main\n\nimport (\n    \"log\"\n    \"libs/golang/clients/resources/go-minio/client\"\n)\n\nfunc main() {\n    config := gominio.Config{\n        Endpoint:  \"localhost:9000\",\n        AccessKey: \"minioaccesskey\",\n        SecretKey: \"miniosecretkey\",\n        UseSSL:    false,\n    }\n    client, err := gominio.NewClient(config)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    uri := \"http://localhost:9000/example-bucket/hello.txt\"\n    content, err := client.DownloadFile(uri)\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Println(\"File content:\", string(content))\n}\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-minio/#removing-an-object","title":"Removing an Object","text":"<pre><code>package main\n\nimport (\n    \"log\"\n    \"libs/golang/clients/resources/go-minio/client\"\n)\n\nfunc main() {\n    config := gominio.Config{\n        Endpoint:  \"localhost:9000\",\n        AccessKey: \"minioaccesskey\",\n        SecretKey: \"miniosecretkey\",\n        UseSSL:    false,\n    }\n    client, err := gominio.NewClient(config)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    bucketName := \"example-bucket\"\n    objectName := \"hello.txt\"\n    err = client.RemoveObject(bucketName, objectName)\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Println(\"Object removed:\", objectName)\n}\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-minio/#removing-all-objects-from-a-bucket","title":"Removing All Objects from a Bucket","text":"<pre><code>package main\n\nimport (\n    \"log\"\n    \"libs/golang/clients/resources/go-minio/client\"\n)\n\nfunc main() {\n    config := gominio.Config{\n        Endpoint:  \"localhost:9000\",\n        AccessKey: \"minioaccesskey\",\n        SecretKey: \"miniosecretkey\",\n        UseSSL:    false,\n    }\n    client, err := gominio.NewClient(config)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    bucketName := \"example-bucket\"\n    err = client.RemoveAllObjectsFromBucket(bucketName)\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Println(\"All objects removed from bucket:\", bucketName)\n}\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-minio/#testing","title":"Testing","text":"<p>To run the tests for the <code>gominio</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-clients-resources-go-minio\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-minio/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/clients/resources/go-minio/docs/godoc/#gominio","title":"gominio","text":"<pre><code>import \"libs/golang/clients/resources/go-minio/client\"\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-minio/docs/godoc/#index","title":"Index","text":"<ul> <li>type Client</li> <li>func NewClient(config Config) (*Client, error)</li> <li>func (c *Client) DownloadFile(uri string) ([]byte, error)</li> <li>func (c *Client) GetObject(bucketName, fileName string) ([]byte, error)</li> <li>func (c *Client) RemoveAllObjectsFromBucket(bucketName string) error</li> <li>func (c *Client) RemoveObject(bucketName, objectName string) error</li> <li>func (c *Client) UploadFile(bucketName, fileName string, fileContent []byte) (string, error)</li> <li>func (c *Client) UploadFileWithChunks(bucketName, fileName string, fileContent []byte, partSize int64) (string, error)</li> <li>type Config</li> </ul>"},{"location":"reference/libs/golang/clients/resources/go-minio/docs/godoc/#type-client","title":"type Client","text":"<p>Client wraps the Minio client to provide additional functionality.</p> <pre><code>type Client struct {\n    *minio.Client\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-minio/docs/godoc/#func-newclient","title":"func NewClient","text":"<pre><code>func NewClient(config Config) (*Client, error)\n</code></pre> <p>NewClient creates a new Minio client with the given configuration. It returns the Client and an error if any occurred during connection.</p> <p>Example:</p> <pre><code>config := Config{\n     Port:      \"9000\",\n     Host:      \"localhost\",\n        AccessKey: \"minioaccesskey\",\n        SecretKey: \"miniosecretkey\",\n        UseSSL:    false,\n    }\n    client, err := NewClient(config)\n    if err != nil {\n        log.Fatal(err)\n    }\n</code></pre> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-minio/docs/godoc/#func-client-downloadfile","title":"func (*Client) DownloadFile","text":"<pre><code>func (c *Client) DownloadFile(uri string) ([]byte, error)\n</code></pre> <p>DownloadFile downloads a file from the specified URI and returns its content as a byte slice.</p> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-minio/docs/godoc/#func-client-getobject","title":"func (*Client) GetObject","text":"<pre><code>func (c *Client) GetObject(bucketName, fileName string) ([]byte, error)\n</code></pre> <p>GetObject retrieves an object from the specified bucket and returns its content as a byte slice.</p> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-minio/docs/godoc/#func-client-removeallobjectsfrombucket","title":"func (*Client) RemoveAllObjectsFromBucket","text":"<pre><code>func (c *Client) RemoveAllObjectsFromBucket(bucketName string) error\n</code></pre> <p>RemoveAllObjectsFromBucket removes all objects from the specified bucket.</p> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-minio/docs/godoc/#func-client-removeobject","title":"func (*Client) RemoveObject","text":"<pre><code>func (c *Client) RemoveObject(bucketName, objectName string) error\n</code></pre> <p>RemoveObject removes an object from the specified bucket.</p> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-minio/docs/godoc/#func-client-uploadfile","title":"func (*Client) UploadFile","text":"<pre><code>func (c *Client) UploadFile(bucketName, fileName string, fileContent []byte) (string, error)\n</code></pre> <p>UploadFile uploads a file to the specified bucket and returns the path to the uploaded file.</p> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-minio/docs/godoc/#func-client-uploadfilewithchunks","title":"func (*Client) UploadFileWithChunks","text":"<pre><code>func (c *Client) UploadFileWithChunks(bucketName, fileName string, fileContent []byte, partSize int64) (string, error)\n</code></pre> <p>UploadFileWithChunks uploads a file in chunks of a specified size to the specified bucket and returns the path to the uploaded parts.</p> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-minio/docs/godoc/#type-config","title":"type Config","text":"<p>Config holds the configuration for connecting to a Minio instance.</p> <pre><code>type Config struct {\n    Port      string // Minio server port\n    Host      string // Minio server host\n    AccessKey string // Access key for authentication\n    SecretKey string // Secret key for authentication\n    UseSSL    bool   // Use SSL connection\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/clients/resources/go-mongo/","title":"go-mongo","text":"<p><code>go-mongo</code> is a Go library that provides a MongoDB client wrapper with utilities for connecting to and interacting with a MongoDB database. This library facilitates creating a connection to a MongoDB instance, pinging the server, and disconnecting from it.</p>"},{"location":"reference/libs/golang/clients/resources/go-mongo/#features","title":"Features","text":"<ul> <li>Connect to a MongoDB instance using configuration parameters</li> <li>Ping the MongoDB server to check the connection</li> <li>Disconnect from the MongoDB instance</li> </ul>"},{"location":"reference/libs/golang/clients/resources/go-mongo/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/clients/resources/go-mongo/#creating-a-mongodb-client","title":"Creating a MongoDB Client","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"libs/golang/clients/resources/go-mongo/client\"\n)\n\nfunc main() {\n    config := mongo.Config{\n        User:     \"testuser\",\n        Password: \"testpassword\",\n        Host:     \"localhost\",\n        Port:     \"27017\",\n        DBName:   \"testdb\",\n    }\n\n    client, err := mongo.NewClient(config)\n    if err != nil {\n        log.Fatalf(\"Failed to create MongoDB client: %v\", err)\n    }\n\n    defer client.Disconnect(context.Background())\n\n    fmt.Println(\"Connected to MongoDB\")\n}\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-mongo/#pinging-the-mongodb-server","title":"Pinging the MongoDB Server","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"libs/golang/clients/resources/go-mongo/client\"\n)\n\nfunc main() {\n    config := mongo.Config{\n        User:     \"testuser\",\n        Password: \"testpassword\",\n        Host:     \"localhost\",\n        Port:     \"27017\",\n        DBName:   \"testdb\",\n    }\n\n    client, err := mongo.NewClient(config)\n    if err != nil {\n        log.Fatalf(\"Failed to create MongoDB client: %v\", err)\n    }\n\n    defer client.Disconnect(context.Background())\n\n    err = client.Ping(context.Background(), nil)\n    if err != nil {\n        log.Fatalf(\"Failed to ping MongoDB: %v\", err)\n    }\n\n    fmt.Println(\"MongoDB server is reachable\")\n}\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-mongo/#disconnecting-from-mongodb","title":"Disconnecting from MongoDB","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"libs/golang/clients/resources/go-mongo/client\"\n)\n\nfunc main() {\n    config := mongo.Config{\n        User:     \"testuser\",\n        Password: \"testpassword\",\n        Host:     \"localhost\",\n        Port:     \"27017\",\n        DBName:   \"testdb\",\n    }\n\n    client, err := mongo.NewClient(config)\n    if err != nil {\n        log.Fatalf(\"Failed to create MongoDB client: %v\", err)\n    }\n\n    err = client.Disconnect(context.Background())\n    if err != nil {\n        log.Fatalf(\"Failed to disconnect from MongoDB: %v\", err)\n    }\n\n    fmt.Println(\"Disconnected from MongoDB\")\n}\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-mongo/#testing","title":"Testing","text":"<p>To run the tests for the <code>go-mongo</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-clients-resources-go-mongo\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-mongo/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/clients/resources/go-mongo/docs/godoc/#gomongodb","title":"gomongodb","text":"<pre><code>import \"libs/golang/clients/resources/go-mongo/client\"\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-mongo/docs/godoc/#index","title":"Index","text":"<ul> <li>type Client</li> <li>func NewClient(config Config) (*Client, error)</li> <li>func (c *Client) Disconnect(ctx context.Context) error</li> <li>type Config</li> </ul>"},{"location":"reference/libs/golang/clients/resources/go-mongo/docs/godoc/#type-client","title":"type Client","text":"<p>Client is a wrapper around the mongo.Client.</p> <pre><code>type Client struct {\n    *mongo.Client\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-mongo/docs/godoc/#func-newclient","title":"func NewClient","text":"<pre><code>func NewClient(config Config) (*Client, error)\n</code></pre> <p>NewClient creates a new MongoDB client with the given configuration. It returns the Client and an error if any occurred during connection.</p> <p>Example:</p> <pre><code>config := Config{\n    User:     \"testuser\",\n    Password: \"testpassword\",\n    Host:     \"localhost\",\n    Port:     \"27017\",\n    DBName:   \"testdb\",\n}\nclient, err := NewClient(config)\nif err != nil {\n    log.Fatal(err)\n}\ndefer client.Disconnect(context.Background())\n</code></pre> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-mongo/docs/godoc/#func-client-disconnect","title":"func (*Client) Disconnect","text":"<pre><code>func (c *Client) Disconnect(ctx context.Context) error\n</code></pre> <p>Disconnect closes the connection to the MongoDB instance. It returns an error if any occurred during disconnection.</p> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-mongo/docs/godoc/#type-config","title":"type Config","text":"<p>Config holds the configuration for connecting to a MongoDB instance.</p> <pre><code>type Config struct {\n    User     string // Username for authentication\n    Password string // Password for authentication\n    Host     string // Host of the MongoDB instance\n    Port     string // Port of the MongoDB instance\n    DBName   string // Name of the database to connect to\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/","title":"Index","text":"<p>Here's the updated README file with improved docstrings and consistent formatting:</p>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/#go-rabbitmq","title":"go-rabbitmq","text":"<p><code>go-rabbitmq</code> is a Go library that provides a RabbitMQ client wrapper with utilities for connecting to and interacting with a RabbitMQ server. This library facilitates creating a connection to a RabbitMQ instance, declaring exchanges and queues, binding queues, publishing messages, and consuming messages.</p>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/#features","title":"Features","text":"<ul> <li>Connect to a RabbitMQ instance using configuration parameters</li> <li>Declare exchanges and queues</li> <li>Bind queues to exchanges</li> <li>Publish messages to exchanges</li> <li>Consume messages from queues</li> </ul>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/#creating-a-rabbitmq-client","title":"Creating a RabbitMQ Client","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"libs/golang/clients/resources/go-rabbitmq\"\n)\n\nfunc main() {\n    config := gorabbitmq.Config{\n        User:         \"guest\",\n        Password:     \"guest\",\n        Host:         \"localhost\",\n        Port:         \"5672\",\n        Protocol:     \"amqp\",\n        ExchangeName: \"my_exchange\",\n        ExchangeType: \"direct\",\n    }\n\n    client, err := gorabbitmq.NewClient(config)\n    if err != nil {\n        log.Fatalf(\"Failed to create RabbitMQ client: %v\", err)\n    }\n\n    defer client.Close()\n\n    fmt.Println(\"Connected to RabbitMQ\")\n}\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/#publishing-a-message","title":"Publishing a Message","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"libs/golang/clients/resources/go-rabbitmq\"\n)\n\nfunc main() {\n    config := gorabbitmq.Config{\n        User:         \"guest\",\n        Password:     \"guest\",\n        Host:         \"localhost\",\n        Port:         \"5672\",\n        Protocol:     \"amqp\",\n        ExchangeName: \"my_exchange\",\n        ExchangeType: \"direct\",\n    }\n\n    client, err := gorabbitmq.NewClient(config)\n    if err != nil {\n        log.Fatalf(\"Failed to create RabbitMQ client: %v\", err)\n    }\n\n    defer client.Close()\n\n    ctx := context.Background()\n    message := []byte(\"Hello, RabbitMQ!\")\n    err = client.Publish(ctx, \"text/plain\", message, \"my_routing_key\")\n    if err != nil {\n        log.Fatalf(\"Failed to publish message: %v\", err)\n    }\n\n    fmt.Println(\"Message published\")\n}\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/#sending-notifications","title":"Sending Notifications","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"libs/golang/clients/resources/go-rabbitmq\"\n)\n\nfunc main() {\n    config := gorabbitmq.Config{\n        User:         \"guest\",\n        Password:     \"guest\",\n        Host:         \"localhost\",\n        Port:         \"5672\",\n        Protocol:     \"amqp\",\n        ExchangeName: \"my_exchange\",\n        ExchangeType: \"direct\",\n    }\n\n    client, err := gorabbitmq.NewClient(config)\n    if err != nil {\n        log.Fatalf(\"Failed to create RabbitMQ client: %v\", err)\n    }\n\n    defer client.Close()\n\n    notifier := gorabbitmq.NewRabbitMQNotifier(client)\n    message := []byte(`{\"message\": \"Hello, World!\"}`)\n    err = notifier.Notify(message, \"my_routing_key\")\n    if err != nil {\n        log.Fatalf(\"Failed to send notification: %v\", err)\n    }\n\n    fmt.Println(\"Notification sent\")\n}\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/#consuming-messages","title":"Consuming Messages","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    \"time\"\n    \"libs/golang/clients/resources/go-rabbitmq\"\n    \"github.com/rabbitmq/amqp091-go\"\n)\n\nfunc main() {\n    config := gorabbitmq.Config{\n        User:         \"guest\",\n        Password:     \"guest\",\n        Host:         \"localhost\",\n        Port:         \"5672\",\n        Protocol:     \"amqp\",\n        ExchangeName: \"my_exchange\",\n        ExchangeType: \"direct\",\n    }\n\n    consumerConfig := gorabbitmq.ConsumerConfig{\n        ConsumerName: \"consumer_name\",\n        AutoAck:      false,\n        Args:         nil,\n    }\n\n    queueName := \"test_queue\"\n    routingKey := \"test_key\"\n    msgCh := make(chan amqp.Delivery)\n\n    client, err := gorabbitmq.NewClient(config)\n    if err != nil {\n        log.Fatalf(\"Failed to create RabbitMQ client: %v\", err)\n    }\n\n    defer client.Close()\n\n    consumer := gorabbitmq.NewRabbitMQConsumer(client, consumerConfig)\n    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n    defer cancel()\n\n    go consumer.Consume(ctx, msgCh, queueName, routingKey)\n\n    select {\n    case msg := &lt;-msgCh:\n        log.Printf(\"Received message: %s\", string(msg.Body))\n    case &lt;-ctx.Done():\n        log.Println(\"Did not receive message in time\")\n    }\n}\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/#testing","title":"Testing","text":"<p>To run the tests for the <code>go-rabbitmq</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-clients-resources-go-rabbitmq\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/docs/godoc/#gorabbitmq","title":"gorabbitmq","text":"<pre><code>import \"libs/golang/clients/resources/go-rabbitmq/client\"\n</code></pre>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/docs/godoc/#index","title":"Index","text":"<ul> <li>type Client</li> <li>func NewClient(config Config) (*Client, error)</li> <li>func (c *Client) Close() error</li> <li>type Config</li> <li>type ConsumerConfig</li> <li>type RabbitMQConsumer</li> <li>func NewRabbitMQConsumer(rmqClient *Client, config ConsumerConfig) *RabbitMQConsumer</li> <li>func (c *RabbitMQConsumer) Consume(ctx context.Context, msgCh chan amqp.Delivery, queueName string, routingKey string)</li> <li>func (c *RabbitMQConsumer) Wait()</li> <li>type RabbitMQNotifier</li> <li>func NewRabbitMQNotifier(rmqClient *Client) *RabbitMQNotifier</li> <li>func (n *RabbitMQNotifier) Notify(message []byte, routingKey string) error</li> </ul>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/docs/godoc/#type-client","title":"type Client","text":"<p>Client represents a RabbitMQ client.</p> <pre><code>type Client struct {\n    Dsn          string           // Data Source Name for connecting to RabbitMQ\n    Conn         *amqp.Connection // RabbitMQ connection instance\n    Channel      *amqp.Channel    // RabbitMQ channel instance\n    ExchangeName string           // Name of the RabbitMQ exchange in use\n    ExchangeType string           // Type of the RabbitMQ exchange in use\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/docs/godoc/#func-newclient","title":"func NewClient","text":"<pre><code>func NewClient(config Config) (*Client, error)\n</code></pre> <p>NewClient creates a new RabbitMQ client with the given configuration.</p> <p>Parameters:</p> <ul> <li>config: The configuration for connecting to RabbitMQ.</li> </ul> <p>Returns:</p> <ul> <li>A pointer to the newly created Client.</li> <li>An error if the client could not be created.</li> </ul> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/docs/godoc/#func-client-close","title":"func (*Client) Close","text":"<pre><code>func (c *Client) Close() error\n</code></pre> <p>Close closes the RabbitMQ client's channel and connection.</p> <p>Returns:</p> <ul> <li>An error if the channel or connection could not be closed.</li> </ul> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/docs/godoc/#type-config","title":"type Config","text":"<p>Config holds the configuration for connecting to a RabbitMQ instance.</p> <pre><code>type Config struct {\n    User         string // Username for RabbitMQ authentication\n    Password     string // Password for RabbitMQ authentication\n    Host         string // Host address of the RabbitMQ server\n    Port         string // Port number of the RabbitMQ server\n    Protocol     string // Protocol to use for the connection (e.g., \"amqp\")\n    ExchangeName string // Name of the RabbitMQ exchange to use\n    ExchangeType string // Type of the RabbitMQ exchange (e.g., \"direct\", \"fanout\")\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/docs/godoc/#type-consumerconfig","title":"type ConsumerConfig","text":"<p>ConsumerConfig holds the configuration for the RabbitMQ consumer.</p> <pre><code>type ConsumerConfig struct {\n    ConsumerName string     // Name of the consumer\n    AutoAck      bool       // Automatic acknowledgment flag\n    Args         amqp.Table // Additional arguments for the queue declaration\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/docs/godoc/#type-rabbitmqconsumer","title":"type RabbitMQConsumer","text":"<p>RabbitMQConsumer represents a RabbitMQ consumer.</p> <pre><code>type RabbitMQConsumer struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/docs/godoc/#func-newrabbitmqconsumer","title":"func NewRabbitMQConsumer","text":"<pre><code>func NewRabbitMQConsumer(rmqClient *Client, config ConsumerConfig) *RabbitMQConsumer\n</code></pre> <p>NewRabbitMQConsumer creates a new RabbitMQ consumer with the given configuration.</p> <p>Parameters:</p> <ul> <li>rmqClient: A pointer to a Client instance that is already connected to RabbitMQ.</li> <li>config: The configuration for the consumer.</li> </ul> <p>Returns:</p> <ul> <li>A pointer to the newly created RabbitMQConsumer.</li> </ul> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/docs/godoc/#func-rabbitmqconsumer-consume","title":"func (*RabbitMQConsumer) Consume","text":"<pre><code>func (c *RabbitMQConsumer) Consume(ctx context.Context, msgCh chan amqp.Delivery, queueName string, routingKey string)\n</code></pre> <p>Consume starts consuming messages from the specified queue and sends them to the provided channel.</p> <p>Parameters:</p> <ul> <li>ctx: The context to use for the consumer.</li> <li>msgCh: A channel to send the consumed messages to.</li> <li>queueName: The name of the queue to consume messages from.</li> <li>routingKey: The routing key to use for binding the queue.</li> </ul> <p>This method will panic if the queue declaration, binding, or consumption fails.</p> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/docs/godoc/#func-rabbitmqconsumer-wait","title":"func (*RabbitMQConsumer) Wait","text":"<pre><code>func (c *RabbitMQConsumer) Wait()\n</code></pre> <p>Wait waits for all goroutines to finish.</p> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/docs/godoc/#type-rabbitmqnotifier","title":"type RabbitMQNotifier","text":"<p>RabbitMQNotifier is a struct that handles sending notifications through RabbitMQ.</p> <pre><code>type RabbitMQNotifier struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/docs/godoc/#func-newrabbitmqnotifier","title":"func NewRabbitMQNotifier","text":"<pre><code>func NewRabbitMQNotifier(rmqClient *Client) *RabbitMQNotifier\n</code></pre> <p>NewRabbitMQNotifier creates a new RabbitMQNotifier with the given RabbitMQ client.</p> <p>Parameters:</p> <ul> <li>rmqClient: A pointer to a Client instance that is already connected to RabbitMQ.</li> </ul> <p>Returns:</p> <ul> <li>A pointer to the newly created RabbitMQNotifier.</li> </ul> <p></p>"},{"location":"reference/libs/golang/clients/resources/go-rabbitmq/docs/godoc/#func-rabbitmqnotifier-notify","title":"func (*RabbitMQNotifier) Notify","text":"<pre><code>func (n *RabbitMQNotifier) Notify(message []byte, routingKey string) error\n</code></pre> <p>Notify sends a notification message to the RabbitMQ exchange using the specified routing key.</p> <p>Parameters:</p> <ul> <li>message: The message to be sent as a byte slice.</li> <li>routingKey: The routing key to be used for routing the message.</li> </ul> <p>Returns:</p> <ul> <li>An error if the message could not be published, or nil if the message was successfully published.</li> </ul> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/","title":"config-vault/handlers","text":"<p><code>config-vault/handlers</code> is a Go library that provides HTTP handlers for managing configuration entities within a web application. This library includes functionalities for creating, reading, updating, and deleting configuration entities through HTTP requests.</p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/#features","title":"Features","text":"<ul> <li>Create, read, update, and delete configuration entities via HTTP requests.</li> <li>List configurations based on various attributes such as service, provider, and source.</li> <li>Handle input validation and error responses.</li> </ul>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/ddd/adapters/http/handlers/#creating-a-webconfighandler","title":"Creating a WebConfigHandler","text":"<p>The <code>WebConfigHandler</code> struct provides methods to handle HTTP requests for configuration operations.</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"net/http\"\n\n    \"libs/golang/ddd/adapters/http/handlers/config-vault/handlers\"\n    \"libs/golang/ddd/domain/entities/config-vault/entity\"\n    \"libs/golang/ddd/domain/repositories/database/mongodb/config-vault/repository\"\n\n    \"go.mongodb.org/mongo-driver/mongo\"\n    \"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\nfunc main() {\n    clientOptions := options.Client().ApplyURI(\"mongodb://localhost:27017\")\n    client, err := mongo.Connect(context.Background(), clientOptions)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    repo := repository.NewConfigRepository(client, \"testdb\")\n    handler := handlers.NewWebConfigHandler(repo)\n\n    http.HandleFunc(\"/configs\", handler.CreateConfig)\n    http.HandleFunc(\"/configs\", handler.UpdateConfig)\n    http.HandleFunc(\"/configs\", handler.DeleteConfig)\n    http.HandleFunc(\"/configs\", handler.ListAllConfigs)\n    http.HandleFunc(\"/configs\", handler.ListConfigByID)\n    http.HandleFunc(\"/configs\", handler.ListConfigsByServiceAndProvider)\n    http.HandleFunc(\"/configs\", handler.ListConfigsBySourceAndProvider)\n    http.HandleFunc(\"/configs\", handler.ListConfigsByServiceAndSourceAndProvider)\n    http.HandleFunc(\"/configs\", handler.ListConfigsByServiceAndProviderAndActive)\n    http.HandleFunc(\"/configs/depends-on\", handler.ListConfigsByProviderAndDependencies)\n\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/#testing","title":"Testing","text":"<p>To run the tests for the <code>handlers</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-ddd-adapters-http-handlers-config-vault\n</code></pre>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/#error-handling","title":"Error Handling","text":"<p>The handlers include error handling for various scenarios, such as:</p> <ul> <li>Invalid request body</li> <li>Missing required query parameters</li> <li>Internal server errors during use case execution</li> </ul> <p>These errors are responded to with appropriate HTTP status codes and error messages.</p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/config-vault/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/ddd/adapters/http/handlers/config-vault/docs/godoc/#handlers","title":"handlers","text":"<pre><code>import \"libs/golang/ddd/adapters/http/handlers/config-vault/handlers\"\n</code></pre>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/config-vault/docs/godoc/#index","title":"Index","text":"<ul> <li>type WebConfigHandler</li> <li>func NewWebConfigHandler(ConfigRepository entity.ConfigRepositoryInterface) *WebConfigHandler</li> <li>func (h *WebConfigHandler) CreateConfig(w http.ResponseWriter, r *http.Request)</li> <li>func (h *WebConfigHandler) DeleteConfig(w http.ResponseWriter, r *http.Request)</li> <li>func (h *WebConfigHandler) ListAllConfigs(w http.ResponseWriter, r *http.Request)</li> <li>func (h *WebConfigHandler) ListConfigByID(w http.ResponseWriter, r *http.Request)</li> <li>func (h *WebConfigHandler) ListConfigsByProviderAndDependencies(w http.ResponseWriter, r *http.Request)</li> <li>func (h *WebConfigHandler) ListConfigsByServiceAndProvider(w http.ResponseWriter, r *http.Request)</li> <li>func (h *WebConfigHandler) ListConfigsByServiceAndProviderAndActive(w http.ResponseWriter, r *http.Request)</li> <li>func (h *WebConfigHandler) ListConfigsByServiceAndSourceAndProvider(w http.ResponseWriter, r *http.Request)</li> <li>func (h *WebConfigHandler) ListConfigsBySourceAndProvider(w http.ResponseWriter, r *http.Request)</li> <li>func (h *WebConfigHandler) UpdateConfig(w http.ResponseWriter, r *http.Request)</li> </ul>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/config-vault/docs/godoc/#type-webconfighandler","title":"type WebConfigHandler","text":"<p>WebConfigHandler handles HTTP requests for configuration operations.</p> <pre><code>type WebConfigHandler struct {\n    ConfigRepository entity.ConfigRepositoryInterface\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/config-vault/docs/godoc/#func-newwebconfighandler","title":"func NewWebConfigHandler","text":"<pre><code>func NewWebConfigHandler(ConfigRepository entity.ConfigRepositoryInterface) *WebConfigHandler\n</code></pre> <p>NewWebConfigHandler creates and returns a new WebConfigHandler instance with the provided ConfigRepository.</p> <p>Parameters:</p> <pre><code>configRepository: The repository interface for managing Config entities.\n</code></pre> <p>Returns:</p> <pre><code>A new WebConfigHandler instance.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/config-vault/docs/godoc/#func-webconfighandler-createconfig","title":"func (*WebConfigHandler) CreateConfig","text":"<pre><code>func (h *WebConfigHandler) CreateConfig(w http.ResponseWriter, r *http.Request)\n</code></pre> <p>CreateConfig handles HTTP POST requests to create a new configuration. It decodes the request body into a ConfigDTO, executes the CreateConfigUseCase, and writes the created configuration as a JSON response.</p> <p>Parameters:</p> <pre><code>w: The HTTP response writer.\nr: The HTTP request.\n</code></pre> <p>Returns:</p> <pre><code>None.\n</code></pre> <p>If the request body cannot be decoded, it responds with HTTP status 400 (Bad Request). If an error occurs during the creation process, it responds with HTTP status 500 (Internal Server Error).</p> <p></p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/config-vault/docs/godoc/#func-webconfighandler-deleteconfig","title":"func (*WebConfigHandler) DeleteConfig","text":"<pre><code>func (h *WebConfigHandler) DeleteConfig(w http.ResponseWriter, r *http.Request)\n</code></pre> <p>DeleteConfig handles HTTP DELETE requests to delete an existing configuration by its ID. It extracts the ID from the query parameters, executes the DeleteConfigUseCase, and writes a success message.</p> <p>Parameters:</p> <pre><code>w: The HTTP response writer.\nr: The HTTP request.\n</code></pre> <p>Returns:</p> <pre><code>None.\n</code></pre> <p>If the ID is not provided or an error occurs during the deletion process, it responds with the appropriate HTTP status code.</p> <p></p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/config-vault/docs/godoc/#func-webconfighandler-listallconfigs","title":"func (*WebConfigHandler) ListAllConfigs","text":"<pre><code>func (h *WebConfigHandler) ListAllConfigs(w http.ResponseWriter, r *http.Request)\n</code></pre> <p>ListAllConfigs handles HTTP GET requests to list all configurations. It executes the ListAllConfigUseCase and writes the list of configurations as a JSON response.</p> <p>Parameters:</p> <pre><code>w: The HTTP response writer.\nr: The HTTP request.\n</code></pre> <p>Returns:</p> <pre><code>None.\n</code></pre> <p>If an error occurs during the listing process, it responds with HTTP status 500 (Internal Server Error).</p> <p></p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/config-vault/docs/godoc/#func-webconfighandler-listconfigbyid","title":"func (*WebConfigHandler) ListConfigByID","text":"<pre><code>func (h *WebConfigHandler) ListConfigByID(w http.ResponseWriter, r *http.Request)\n</code></pre> <p>ListConfigByID handles HTTP GET requests to list a configuration by its ID. It extracts the ID from the query parameters, executes the ListOneByIDConfigUseCase, and writes the configuration as a JSON response.</p> <p>Parameters:</p> <pre><code>w: The HTTP response writer.\nr: The HTTP request.\n</code></pre> <p>Returns:</p> <pre><code>None.\n</code></pre> <p>If the ID is not provided or an error occurs during the listing process, it responds with the appropriate HTTP status code.</p> <p></p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/config-vault/docs/godoc/#func-webconfighandler-listconfigsbyprovideranddependencies","title":"func (*WebConfigHandler) ListConfigsByProviderAndDependencies","text":"<pre><code>func (h *WebConfigHandler) ListConfigsByProviderAndDependencies(w http.ResponseWriter, r *http.Request)\n</code></pre> <p>ListConfigsByProviderAndDependencies handles HTTP GET requests to list configurations by their dependencies. It extracts the dependencies from the query parameters, executes the ListAllByProviderAndDependsOnConfigUseCase, and writes the list of configurations as a JSON response.</p> <p>Parameters:</p> <pre><code>w: The HTTP response writer.\nr: The HTTP request.\n</code></pre> <p>Returns:</p> <pre><code>None.\n</code></pre> <p>If the dependencies are not provided or an error occurs during the listing process, it responds with the appropriate HTTP status code.</p> <p></p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/config-vault/docs/godoc/#func-webconfighandler-listconfigsbyserviceandprovider","title":"func (*WebConfigHandler) ListConfigsByServiceAndProvider","text":"<pre><code>func (h *WebConfigHandler) ListConfigsByServiceAndProvider(w http.ResponseWriter, r *http.Request)\n</code></pre> <p>ListConfigsByServiceAndProvider handles HTTP GET requests to list configurations by service and provider. It extracts the service and provider from the query parameters, executes the ListByServiceAndProviderConfigUseCase, and writes the list of configurations as a JSON response.</p> <p>Parameters:</p> <pre><code>w: The HTTP response writer.\nr: The HTTP request.\n</code></pre> <p>Returns:</p> <pre><code>None.\n</code></pre> <p>If the service or provider is not provided or an error occurs during the listing process, it responds with the appropriate HTTP status code.</p> <p></p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/config-vault/docs/godoc/#func-webconfighandler-listconfigsbyserviceandproviderandactive","title":"func (*WebConfigHandler) ListConfigsByServiceAndProviderAndActive","text":"<pre><code>func (h *WebConfigHandler) ListConfigsByServiceAndProviderAndActive(w http.ResponseWriter, r *http.Request)\n</code></pre> <p>ListConfigsByServiceAndProviderAndActive handles HTTP GET requests to list configurations by service, provider, and active status. It extracts the service, provider, and active status from the query parameters, executes the ListByServiceAndProviderAndActiveConfigUseCase, and writes the list of configurations as a JSON response.</p> <p>Parameters:</p> <pre><code>w: The HTTP response writer.\nr: The HTTP request.\n</code></pre> <p>Returns:</p> <pre><code>None.\n</code></pre> <p>If the service, provider, or active status is not provided or an error occurs during the listing process, it responds with the appropriate HTTP status code.</p> <p></p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/config-vault/docs/godoc/#func-webconfighandler-listconfigsbyserviceandsourceandprovider","title":"func (*WebConfigHandler) ListConfigsByServiceAndSourceAndProvider","text":"<pre><code>func (h *WebConfigHandler) ListConfigsByServiceAndSourceAndProvider(w http.ResponseWriter, r *http.Request)\n</code></pre> <p>ListConfigsByServiceAndSourceAndProvider handles HTTP GET requests to list configurations by service, source, and provider. It extracts the service, source, and provider from the query parameters, executes the ListByServiceAndSourceAndProviderConfigUseCase, and writes the list of configurations as a JSON response.</p> <p>Parameters:</p> <pre><code>w: The HTTP response writer.\nr: The HTTP request.\n</code></pre> <p>Returns:</p> <pre><code>None.\n</code></pre> <p>If the service, source, or provider is not provided or an error occurs during the listing process, it responds with the appropriate HTTP status code.</p> <p></p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/config-vault/docs/godoc/#func-webconfighandler-listconfigsbysourceandprovider","title":"func (*WebConfigHandler) ListConfigsBySourceAndProvider","text":"<pre><code>func (h *WebConfigHandler) ListConfigsBySourceAndProvider(w http.ResponseWriter, r *http.Request)\n</code></pre> <p>ListConfigsBySourceAndProvider handles HTTP GET requests to list configurations by source and provider. It extracts the source and provider from the query parameters, executes the ListBySourceAndProviderConfigUseCase, and writes the list of configurations as a JSON response.</p> <p>Parameters:</p> <pre><code>w: The HTTP response writer.\nr: The HTTP request.\n</code></pre> <p>Returns:</p> <pre><code>None.\n</code></pre> <p>If the source or provider is not provided or an error occurs during the listing process, it responds with the appropriate HTTP status code.</p> <p></p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/config-vault/docs/godoc/#func-webconfighandler-updateconfig","title":"func (*WebConfigHandler) UpdateConfig","text":"<pre><code>func (h *WebConfigHandler) UpdateConfig(w http.ResponseWriter, r *http.Request)\n</code></pre> <p>UpdateConfig handles HTTP PUT requests to update an existing configuration. It decodes the request body into a ConfigDTO, executes the UpdateConfigUseCase, and writes the updated configuration as a JSON response.</p> <p>Parameters:</p> <pre><code>w: The HTTP response writer.\nr: The HTTP request.\n</code></pre> <p>Returns:</p> <pre><code>None.\n</code></pre> <p>If the request body cannot be decoded, it responds with HTTP status 400 (Bad Request). If an error occurs during the update process, it responds with HTTP status 500 (Internal Server Error).</p> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/","title":"healthz","text":"<p>The <code>healthz</code> package is a Go library that provides a handler for HTTP health checks. This library allows you to monitor the health status of your server by checking its uptime and readiness. It supports customizable time providers to facilitate testing and real-time monitoring.</p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/#features","title":"Features","text":"<ul> <li>HTTP handler for health checks</li> <li>Customizable time providers for flexibility and testability</li> <li>Responds with appropriate HTTP status codes based on server uptime</li> </ul>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/#creating-a-health-check-handler","title":"Creating a Health Check Handler","text":"<p>The <code>WebHealthzHandler</code> struct is used to handle health check requests. You can create a new instance of this handler using the <code>NewWebHealthzHandler</code> function, which accepts a <code>TimeProvider</code> to manage time-related functions.</p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/#example-with-realtimeprovider","title":"Example with RealTimeProvider","text":"<pre><code>package main\n\nimport (\n    \"net/http\"\n    \"libs/golang/ddd/adapters/http/handlers/health-check/healthz\"\n)\n\nfunc main() {\n    timeProvider := &amp;healthz.RealTimeProvider{}\n    handler := healthz.NewWebHealthzHandler(timeProvider)\n\n    http.HandleFunc(\"/healthz\", handler.Healthz)\n    http.ListenAndServe(\":8080\", nil)\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/#implementing-custom-time-providers","title":"Implementing Custom Time Providers","text":"<p>You can implement the <code>TimeProvider</code> interface to create your own custom time providers. This is useful for testing or for integrating with other time-based systems.</p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/#example","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"time\"\n)\n\ntype CustomTimeProvider struct{}\n\nfunc (c *CustomTimeProvider) Now() time.Time {\n    // Custom implementation\n}\n\nfunc (c *CustomTimeProvider) Since(t time.Time) time.Duration {\n    // Custom implementation\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/#testing","title":"Testing","text":"<p>To run the tests for the <code>healthz</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-ddd-adapters-http-handlers-health-check\n</code></pre>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/docs/godoc/#healthz","title":"healthz","text":"<pre><code>import \"libs/golang/ddd/adapters/http/handlers/health-check/healthz\"\n</code></pre>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/docs/godoc/#index","title":"Index","text":"<ul> <li>type MockTimeProvider</li> <li>func (m *MockTimeProvider) Advance(d time.Duration)</li> <li>func (m *MockTimeProvider) Now() time.Time</li> <li>func (m *MockTimeProvider) Since(t time.Time) time.Duration</li> <li>type RealTimeProvider</li> <li>func (r *RealTimeProvider) Now() time.Time</li> <li>func (r *RealTimeProvider) Since(t time.Time) time.Duration</li> <li>type TimeProvider</li> <li>type WebHealthzHandler</li> <li>func NewWebHealthzHandler(timeProvider TimeProvider, minUptime time.Duration) *WebHealthzHandler</li> <li>func (h *WebHealthzHandler) Healthz(w http.ResponseWriter, r *http.Request)</li> </ul>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/docs/godoc/#type-mocktimeprovider","title":"type MockTimeProvider","text":"<pre><code>type MockTimeProvider struct {\n    // contains filtered or unexported fields\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/docs/godoc/#func-mocktimeprovider-advance","title":"func (*MockTimeProvider) Advance","text":"<pre><code>func (m *MockTimeProvider) Advance(d time.Duration)\n</code></pre>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/docs/godoc/#func-mocktimeprovider-now","title":"func (*MockTimeProvider) Now","text":"<pre><code>func (m *MockTimeProvider) Now() time.Time\n</code></pre>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/docs/godoc/#func-mocktimeprovider-since","title":"func (*MockTimeProvider) Since","text":"<pre><code>func (m *MockTimeProvider) Since(t time.Time) time.Duration\n</code></pre>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/docs/godoc/#type-realtimeprovider","title":"type RealTimeProvider","text":"<p>RealTimeProvider is a struct that implements the TimeProvider interface using the real time functions from the time package.</p> <pre><code>type RealTimeProvider struct{}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/docs/godoc/#func-realtimeprovider-now","title":"func (*RealTimeProvider) Now","text":"<pre><code>func (r *RealTimeProvider) Now() time.Time\n</code></pre> <p>Now returns the current local time.</p> <p></p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/docs/godoc/#func-realtimeprovider-since","title":"func (*RealTimeProvider) Since","text":"<pre><code>func (r *RealTimeProvider) Since(t time.Time) time.Duration\n</code></pre> <p>Since returns the time elapsed since t.</p> <p></p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/docs/godoc/#type-timeprovider","title":"type TimeProvider","text":"<p>TimeProvider is an interface that abstracts time-related functions, allowing for easier testing by enabling the use of mock time providers.</p> <pre><code>type TimeProvider interface {\n    Now() time.Time\n    Since(t time.Time) time.Duration\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/docs/godoc/#type-webhealthzhandler","title":"type WebHealthzHandler","text":"<p>WebHealthzHandler handles HTTP requests for health checks, providing information about the server's uptime and readiness.</p> <pre><code>type WebHealthzHandler struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/docs/godoc/#func-newwebhealthzhandler","title":"func NewWebHealthzHandler","text":"<pre><code>func NewWebHealthzHandler(timeProvider TimeProvider, minUptime time.Duration) *WebHealthzHandler\n</code></pre> <p>NewWebHealthzHandler creates and returns a new WebHealthzHandler instance with the specified TimeProvider. This allows for both real and mock time providers.</p> <p>Parameters:</p> <ul> <li>timeProvider: An implementation of the TimeProvider interface for time-related functions.</li> <li>minUptime: The minimum uptime required for the server to be considered healthy.</li> </ul> <p>Returns:</p> <ul> <li>A new instance of WebHealthzHandler.</li> </ul> <p></p>"},{"location":"reference/libs/golang/ddd/adapters/http/handlers/health-check/docs/godoc/#func-webhealthzhandler-healthz","title":"func (*WebHealthzHandler) Healthz","text":"<pre><code>func (h *WebHealthzHandler) Healthz(w http.ResponseWriter, r *http.Request)\n</code></pre> <p>Healthz is an HTTP handler function that checks the health status of the server. If the server has been running for less than the minimum uptime required, it responds with a 500 Internal Server Error status. Otherwise, it responds with a 200 OK status.</p> <p>Parameters:</p> <ul> <li>w: The ResponseWriter to write the HTTP response.</li> <li>r: The HTTP request being handled.</li> </ul> <p>Returns:</p> <ul> <li>None.</li> </ul> <p>Example:</p> <pre><code>http.HandleFunc(\"/healthz\", handler.Healthz)\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/","title":"config-vault/entity","text":"<p><code>config-vault/entity</code> is a Go library that provides structures and functions to manage and manipulate configuration entities within a system. This library includes utilities for converting data between different formats, validating configuration data, and generating necessary identifiers.</p>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/#features","title":"Features","text":"<ul> <li>Define and manage configuration entities.</li> <li>Convert between <code>map[string]interface{}</code> and entity structs.</li> <li>Validate configuration data.</li> <li>Generate and handle MD5 and UUID identifiers.</li> </ul>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/#defining-configuration-entities","title":"Defining Configuration Entities","text":"<p>The <code>Config</code> struct represents a configuration entity with attributes such as service, source, provider, and dependencies.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/ddd/domain/entities/config-vault/entity\"\n)\n\nfunc main() {\n    configProps := entity.ConfigProps{\n        Active:   true,\n        Service:  \"exampleService\",\n        Source:   \"exampleSource\",\n        Provider: \"exampleProvider\",\n        DependsOn: []map[string]interface{}{\n            {\"service\": \"dependencyService\", \"source\": \"dependencySource\"},\n        },\n    }\n\n    config, err := entity.NewConfig(configProps)\n    if err != nil {\n        fmt.Println(\"Error creating config:\", err)\n        return\n    }\n\n    fmt.Printf(\"Config: %+v\\n\", config)\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/#converting-configuration-entities-to-maps","title":"Converting Configuration Entities to Maps","text":"<p>The <code>ToMap</code> method converts a <code>Config</code> entity to a <code>map[string]interface{}</code> representation.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/ddd/domain/entities/config-vault/entity\"\n)\n\nfunc main() {\n    configProps := entity.ConfigProps{\n        Active:   true,\n        Service:  \"exampleService\",\n        Source:   \"exampleSource\",\n        Provider: \"exampleProvider\",\n        DependsOn: []map[string]interface{}{\n            {\"service\": \"dependencyService\", \"source\": \"dependencySource\"},\n        },\n    }\n\n    config, err := entity.NewConfig(configProps)\n    if err != nil {\n        fmt.Println(\"Error creating config:\", err)\n        return\n    }\n\n    configMap, err := config.ToMap()\n    if err != nil {\n        fmt.Println(\"Error converting config to map:\", err)\n        return\n    }\n\n    fmt.Printf(\"Config as map: %+v\\n\", configMap)\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/#validating-configuration-entities","title":"Validating Configuration Entities","text":"<p>The <code>isValid</code> method ensures that all required fields of a <code>Config</code> entity are set.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/ddd/domain/entities/config-vault/entity\"\n)\n\nfunc main() {\n    configProps := entity.ConfigProps{\n        Active:   true,\n        Service:  \"exampleService\",\n        Source:   \"exampleSource\",\n        Provider: \"exampleProvider\",\n        DependsOn: []map[string]interface{}{\n            {\"service\": \"dependencyService\", \"source\": \"dependencySource\"},\n        },\n    }\n\n    config, err := entity.NewConfig(configProps)\n    if err != nil {\n        fmt.Println(\"Error creating config:\", err)\n        return\n    }\n\n    err = config.isValid()\n    if err != nil {\n        fmt.Println(\"Config is invalid:\", err)\n        return\n    }\n\n    fmt.Println(\"Config is valid\")\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/#testing","title":"Testing","text":"<p>To run the tests for the <code>entity</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-ddd-domain-entities-config-vault\n</code></pre>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/#errors","title":"Errors","text":"<ul> <li><code>ErrInvalidID</code>: Returned when the ID of a <code>Config</code> is invalid.</li> <li><code>ErrInvalidService</code>: Returned when the service of a <code>Config</code> is invalid.</li> <li><code>ErrInvalidSource</code>: Returned when the source of a <code>Config</code> is invalid.</li> <li><code>ErrInvalidProvider</code>: Returned when the provider of a <code>Config</code> is invalid.</li> <li><code>ErrInvalidConfigVersionID</code>: Returned when the config version ID of a <code>Config</code> is invalid.</li> <li><code>ErrInvalidCreatedAt</code>: Returned when the created at timestamp of a <code>Config</code> is invalid.</li> </ul>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/docs/godoc/#entity","title":"entity","text":"<pre><code>import \"libs/golang/ddd/domain/entities/config-vault/entity\"\n</code></pre>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/docs/godoc/#index","title":"Index","text":"<ul> <li>Variables</li> <li>type Config</li> <li>func NewConfig(configProps ConfigProps) (*Config, error)</li> <li>func (c *Config) GetEntityID() string</li> <li>func (c *Config) GetVersionIDData() map[string]interface{}</li> <li>func (c *Config) MapToEntity(doc map[string]interface{}) (*Config, error)</li> <li>func (c *Config) SetConfigVersionID(configVersionID uuid.ID)</li> <li>func (c *Config) SetCreatedAt(createdAt string)</li> <li>func (c *Config) SetDependsOn(dependsOn []JobDependencies)</li> <li>func (c *Config) ToMap() (map[string]interface{}, error)</li> <li>type ConfigProps</li> <li>type ConfigRepositoryInterface</li> <li>type JobDependencies</li> </ul>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/docs/godoc/#variables","title":"Variables","text":"<pre><code>var (\n    // ErrInvalidID is returned when the ID of a Config is invalid.\n    ErrInvalidID = errors.New(\"invalid ID\")\n\n    // ErrInvalidService is returned when the service of a Config is invalid.\n    ErrInvalidService = errors.New(\"invalid service\")\n\n    // ErrInvalidSource is returned when the source of a Config is invalid.\n    ErrInvalidSource = errors.New(\"invalid source\")\n\n    // ErrInvalidProvider is returned when the provider of a Config is invalid.\n    ErrInvalidProvider = errors.New(\"invalid provider\")\n\n    // ErrInvalidConfigVersionID is returned when the config version ID of a Config is invalid.\n    ErrInvalidConfigVersionID = errors.New(\"invalid config version ID\")\n\n    // ErrInvalidCreatedAt is returned when the created at timestamp of a Config is invalid.\n    ErrInvalidCreatedAt = errors.New(\"invalid created at\")\n)\n</code></pre>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/docs/godoc/#type-config","title":"type Config","text":"<p>Config represents a configuration entity with various attributes such as service, source, provider, and dependencies.</p> <pre><code>type Config struct {\n    ID              md5id.ID          `bson:\"_id\"`\n    Active          bool              `bson:\"active\"`\n    Service         string            `bson:\"service\"`\n    Source          string            `bson:\"source\"`\n    Provider        string            `bson:\"provider\"`\n    DependsOn       []JobDependencies `bson:\"depends_on\"`\n    ConfigVersionID uuid.ID           `bson:\"config_version_id\"`\n    CreatedAt       string            `bson:\"created_at\"`\n    UpdatedAt       string            `bson:\"updated_at\"`\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/docs/godoc/#func-newconfig","title":"func NewConfig","text":"<pre><code>func NewConfig(configProps ConfigProps) (*Config, error)\n</code></pre> <p>NewConfig creates a new Config entity based on the provided ConfigProps. It validates the properties and generates necessary IDs.</p> <p></p>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/docs/godoc/#func-config-getentityid","title":"func (*Config) GetEntityID","text":"<pre><code>func (c *Config) GetEntityID() string\n</code></pre> <p>GetEntityID returns the ID of the Config entity.</p> <p></p>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/docs/godoc/#func-config-getversioniddata","title":"func (*Config) GetVersionIDData","text":"<pre><code>func (c *Config) GetVersionIDData() map[string]interface{}\n</code></pre> <p>GetVersionIDData returns a map with the version ID data for the Config entity.</p> <p></p>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/docs/godoc/#func-config-maptoentity","title":"func (*Config) MapToEntity","text":"<pre><code>func (c *Config) MapToEntity(doc map[string]interface{}) (*Config, error)\n</code></pre> <p>MapToEntity converts a map representation to a Config entity.</p> <p></p>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/docs/godoc/#func-config-setconfigversionid","title":"func (*Config) SetConfigVersionID","text":"<pre><code>func (c *Config) SetConfigVersionID(configVersionID uuid.ID)\n</code></pre> <p>SetConfigVersionID sets the config version ID of the Config entity.</p> <p></p>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/docs/godoc/#func-config-setcreatedat","title":"func (*Config) SetCreatedAt","text":"<pre><code>func (c *Config) SetCreatedAt(createdAt string)\n</code></pre> <p>SetCreatedAt sets the created at timestamp of the Config entity.</p> <p></p>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/docs/godoc/#func-config-setdependson","title":"func (*Config) SetDependsOn","text":"<pre><code>func (c *Config) SetDependsOn(dependsOn []JobDependencies)\n</code></pre> <p>SetDependsOn sets the dependencies of the Config entity.</p> <p></p>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/docs/godoc/#func-config-tomap","title":"func (*Config) ToMap","text":"<pre><code>func (c *Config) ToMap() (map[string]interface{}, error)\n</code></pre> <p>ToMap converts the Config entity to a map representation.</p> <p></p>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/docs/godoc/#type-configprops","title":"type ConfigProps","text":"<p>ConfigProps represents the properties needed to create a new Config entity.</p> <pre><code>type ConfigProps struct {\n    Active    bool\n    Service   string\n    Source    string\n    Provider  string\n    DependsOn []map[string]interface{}\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/docs/godoc/#type-configrepositoryinterface","title":"type ConfigRepositoryInterface","text":"<pre><code>type ConfigRepositoryInterface interface {\n    Create(config *Config) error\n    FindByID(id string) (*Config, error)\n    FindAll() ([]*Config, error)\n    Update(config *Config) error\n    Delete(id string) error\n    FindAllByServiceAndProvider(provider, service string) ([]*Config, error)\n    FindAllBySourceAndProvider(provider, source string) ([]*Config, error)\n    FindAllByServiceAndSourceAndProvider(service, source, provider string) ([]*Config, error)\n    FindAllByServiceAndProviderAndActive(service, provider string, active bool) ([]*Config, error)\n    FindAllByProviderAndDependsOn(provider, service, source string) ([]*Config, error)\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/domain/entities/config-vault/docs/godoc/#type-jobdependencies","title":"type JobDependencies","text":"<p>JobDependencies represents the dependencies of a job, including the service and source.</p> <pre><code>type JobDependencies struct {\n    Service string `json:\"service\"`\n    Source  string `json:\"source\"`\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/","title":"config-vault/mockrepository","text":"<p><code>config-vault/mockrepository</code> is a Go library that provides mock implementations of the repository interfaces used in the <code>config-vault</code> domain. This library is primarily used for testing purposes, allowing you to simulate repository behaviors without needing a real database.</p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/#features","title":"Features","text":"<ul> <li>Mock implementation of <code>ConfigRepositoryInterface</code>.</li> <li>Support for creating, finding, updating, and deleting configuration entities.</li> <li>Support for querying configurations based on various attributes.</li> </ul>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/#mocking-a-config-repository","title":"Mocking a Config Repository","text":"<p>The <code>ConfigRepositoryMock</code> struct provides methods to simulate interactions with configuration entities.</p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/#example","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"testing\"\n\n    \"libs/golang/ddd/domain/entities/config-vault/entity\"\n    \"libs/golang/ddd/domain/repositories/mock/config-vault/repository\"\n    \"github.com/stretchr/testify/mock\"\n)\n\nfunc main() {\n    repoMock := new(mockrepository.ConfigRepositoryMock)\n\n    configProps := entity.ConfigProps{\n        Active:    true,\n        Service:   \"exampleService\",\n        Source:    \"exampleSource\",\n        Provider:  \"exampleProvider\",\n        DependsOn: []map[string]interface{}{\n            {\"service\": \"dependencyService\", \"source\": \"dependencySource\"},\n        },\n    }\n\n    config, err := entity.NewConfig(configProps)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    repoMock.On(\"Create\", config).Return(nil)\n\n    err = repoMock.Create(config)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Mocked config creation: %+v\\n\", config)\n    repoMock.AssertExpectations(&amp;testing.T{})\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/docs/godoc/#mockrepository","title":"mockrepository","text":"<pre><code>import \"libs/golang/ddd/domain/repositories/database/mock/config-vault/repository\"\n</code></pre>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/docs/godoc/#index","title":"Index","text":"<ul> <li>type ConfigRepositoryMock</li> <li>func (m *ConfigRepositoryMock) Create(config *entity.Config) error</li> <li>func (m *ConfigRepositoryMock) Delete(id string) error</li> <li>func (m *ConfigRepositoryMock) FindAll() ([]*entity.Config, error)</li> <li>func (m *ConfigRepositoryMock) FindAllByProviderAndDependsOn(provider, service, source string) ([]*entity.Config, error)</li> <li>func (m *ConfigRepositoryMock) FindAllByServiceAndProvider(provider, service string) ([]*entity.Config, error)</li> <li>func (m *ConfigRepositoryMock) FindAllByServiceAndProviderAndActive(service, provider string, active bool) ([]*entity.Config, error)</li> <li>func (m *ConfigRepositoryMock) FindAllByServiceAndSourceAndProvider(service, source, provider string) ([]*entity.Config, error)</li> <li>func (m *ConfigRepositoryMock) FindAllBySourceAndProvider(provider, source string) ([]*entity.Config, error)</li> <li>func (m *ConfigRepositoryMock) FindByID(id string) (*entity.Config, error)</li> <li>func (m *ConfigRepositoryMock) Update(config *entity.Config) error</li> </ul>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/docs/godoc/#type-configrepositorymock","title":"type ConfigRepositoryMock","text":"<p>ConfigRepositoryMock is a mock implementation of ConfigRepositoryInterface</p> <pre><code>type ConfigRepositoryMock struct {\n    mock.Mock\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/docs/godoc/#func-configrepositorymock-create","title":"func (*ConfigRepositoryMock) Create","text":"<pre><code>func (m *ConfigRepositoryMock) Create(config *entity.Config) error\n</code></pre> <p>Create is a mock implementation of ConfigRepositoryInterface's Create method</p> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/docs/godoc/#func-configrepositorymock-delete","title":"func (*ConfigRepositoryMock) Delete","text":"<pre><code>func (m *ConfigRepositoryMock) Delete(id string) error\n</code></pre> <p>Delete is a mock implementation of ConfigRepositoryInterface's Delete method</p> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/docs/godoc/#func-configrepositorymock-findall","title":"func (*ConfigRepositoryMock) FindAll","text":"<pre><code>func (m *ConfigRepositoryMock) FindAll() ([]*entity.Config, error)\n</code></pre> <p>FindAll is a mock implementation of ConfigRepositoryInterface's FindAll method</p> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/docs/godoc/#func-configrepositorymock-findallbyprovideranddependson","title":"func (*ConfigRepositoryMock) FindAllByProviderAndDependsOn","text":"<pre><code>func (m *ConfigRepositoryMock) FindAllByProviderAndDependsOn(provider, service, source string) ([]*entity.Config, error)\n</code></pre> <p>FindAllByProviderAndDependsOn is a mock implementation of ConfigRepositoryInterface's FindAllByProviderAndDependsOn method</p> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/docs/godoc/#func-configrepositorymock-findallbyserviceandprovider","title":"func (*ConfigRepositoryMock) FindAllByServiceAndProvider","text":"<pre><code>func (m *ConfigRepositoryMock) FindAllByServiceAndProvider(provider, service string) ([]*entity.Config, error)\n</code></pre> <p>FindAllByServiceAndProvider is a mock implementation of ConfigRepositoryInterface's FindAllByServiceAndProvider method</p> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/docs/godoc/#func-configrepositorymock-findallbyserviceandproviderandactive","title":"func (*ConfigRepositoryMock) FindAllByServiceAndProviderAndActive","text":"<pre><code>func (m *ConfigRepositoryMock) FindAllByServiceAndProviderAndActive(service, provider string, active bool) ([]*entity.Config, error)\n</code></pre> <p>FindAllByServiceAndProviderAndActive is a mock implementation of ConfigRepositoryInterface's FindAllByServiceAndProviderAndActive method</p> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/docs/godoc/#func-configrepositorymock-findallbyserviceandsourceandprovider","title":"func (*ConfigRepositoryMock) FindAllByServiceAndSourceAndProvider","text":"<pre><code>func (m *ConfigRepositoryMock) FindAllByServiceAndSourceAndProvider(service, source, provider string) ([]*entity.Config, error)\n</code></pre> <p>FindAllByServiceAndSourceAndProvider is a mock implementation of ConfigRepositoryInterface's FindAllByServiceAndSourceAndProvider method</p> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/docs/godoc/#func-configrepositorymock-findallbysourceandprovider","title":"func (*ConfigRepositoryMock) FindAllBySourceAndProvider","text":"<pre><code>func (m *ConfigRepositoryMock) FindAllBySourceAndProvider(provider, source string) ([]*entity.Config, error)\n</code></pre> <p>FindAllBySourceAndProvider is a mock implementation of ConfigRepositoryInterface's FindAllBySourceAndProvider method</p> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/docs/godoc/#func-configrepositorymock-findbyid","title":"func (*ConfigRepositoryMock) FindByID","text":"<pre><code>func (m *ConfigRepositoryMock) FindByID(id string) (*entity.Config, error)\n</code></pre> <p>FindByID is a mock implementation of ConfigRepositoryInterface's FindByID method</p> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mock/config-vault/docs/godoc/#func-configrepositorymock-update","title":"func (*ConfigRepositoryMock) Update","text":"<pre><code>func (m *ConfigRepositoryMock) Update(config *entity.Config) error\n</code></pre> <p>Update is a mock implementation of ConfigRepositoryInterface's Update method</p> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/","title":"config-vault/repository","text":"<p><code>config-vault/repository</code> is a Go library that provides a repository layer for managing configuration entities stored in MongoDB. This library includes functionalities for creating, reading, updating, and deleting configuration entities, as well as querying configurations based on different attributes.</p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/#features","title":"Features","text":"<ul> <li>Create, read, update, and delete configuration entities in MongoDB.</li> <li>Query configurations by service, source, provider, and other attributes.</li> <li>Handle collection and database existence checks.</li> </ul>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/#creating-a-configrepository","title":"Creating a ConfigRepository","text":"<p>The <code>ConfigRepository</code> struct provides methods to interact with the configuration entities stored in MongoDB.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"libs/golang/ddd/domain/entities/config-vault/entity\"\n    \"libs/golang/ddd/domain/repositories/database/mongodb/config-vault/repository\"\n\n    \"go.mongodb.org/mongo-driver/mongo\"\n    \"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\nfunc main() {\n    clientOptions := options.Client().ApplyURI(\"mongodb://localhost:27017\")\n    client, err := mongo.Connect(context.Background(), clientOptions)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    repo := repository.NewConfigRepository(client, \"testdb\")\n    configProps := entity.ConfigProps{\n        Active:   true,\n        Service:  \"exampleService\",\n        Source:   \"exampleSource\",\n        Provider: \"exampleProvider\",\n        DependsOn: []map[string]interface{}{\n            {\"service\": \"dependencyService\", \"source\": \"dependencySource\"},\n        },\n    }\n\n    config, err := entity.NewConfig(configProps)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    err = repo.Create(config)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Config created: %+v\\n\", config)\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/#retrieving-a-config-by-id","title":"Retrieving a Config by ID","text":"<p>Use the <code>FindByID</code> method to retrieve a configuration by its ID.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"libs/golang/ddd/domain/repositories/database/mongodb/config-vault/repository\"\n\n    \"go.mongodb.org/mongo-driver/mongo\"\n    \"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\nfunc main() {\n    clientOptions := options.Client().ApplyURI(\"mongodb://localhost:27017\")\n    client, err := mongo.Connect(context.Background(), clientOptions)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    repo := repository.NewConfigRepository(client, \"testdb\")\n    config, err := repo.FindByID(\"60d5ec49e17e8e304c8f5310\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Config retrieved: %+v\\n\", config)\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/#updating-a-config","title":"Updating a Config","text":"<p>Use the <code>Update</code> method to update an existing configuration.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"libs/golang/ddd/domain/entities/config-vault/entity\"\n    \"libs/golang/ddd/domain/repositories/database/mongodb/config-vault/repository\"\n\n    \"go.mongodb.org/mongo-driver/mongo\"\n    \"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\nfunc main() {\n    clientOptions := options.Client().ApplyURI(\"mongodb://localhost:27017\")\n    client, err := mongo.Connect(context.Background(), clientOptions)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    repo := repository.NewConfigRepository(client, \"testdb\")\n    config, err := repo.FindByID(\"60d5ec49e17e8e304c8f5310\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    config.SetActive(false)\n    err = repo.Update(config)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(\"Config updated successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/#deleting-a-config","title":"Deleting a Config","text":"<p>Use the <code>Delete</code> method to remove a configuration by its ID.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"libs/golang/ddd/domain/repositories/database/mongodb/config-vault/repository\"\n\n    \"go.mongodb.org/mongo-driver/mongo\"\n    \"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\nfunc main() {\n    clientOptions := options.Client().ApplyURI(\"mongodb://localhost:27017\")\n    client, err := mongo.Connect(context.Background(), clientOptions)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    repo := repository.NewConfigRepository(client, \"testdb\")\n    err = repo.Delete(\"60d5ec49e17e8e304c8f5310\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(\"Config deleted successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/#querying-configurations","title":"Querying Configurations","text":"<p>Use the various query methods to retrieve configurations based on different attributes.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"libs/golang/ddd/domain/repositories/database/mongodb/config-vault/repository\"\n\n    \"go.mongodb.org/mongo-driver/mongo\"\n    \"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\nfunc main() {\n    clientOptions := options.Client().ApplyURI(\"mongodb://localhost:27017\")\n    client, err := mongo.Connect(context.Background(), clientOptions)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    repo := repository.NewConfigRepository(client, \"testdb\")\n    configs, err := repo.FindAllByServiceAndProvider(\"exampleProvider\", \"exampleService\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    for _, config := range configs {\n        fmt.Printf(\"Config: %+v\\n\", config)\n    }\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/#testing","title":"Testing","text":"<p>To run the tests for the <code>repository</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-ddd-domain-repositories-database-mongodb-config-vault-repository\n</code></pre>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/docs/godoc/#repository","title":"repository","text":"<pre><code>import \"libs/golang/ddd/domain/repositories/database/mongodb/config-vault/repository\"\n</code></pre>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/docs/godoc/#index","title":"Index","text":"<ul> <li>type ConfigRepository</li> <li>func NewConfigRepository(client *mongo.Client, database string) *ConfigRepository</li> <li>func (r *ConfigRepository) Create(config *entity.Config) error</li> <li>func (r *ConfigRepository) Delete(id string) error</li> <li>func (r *ConfigRepository) FindAll() ([]*entity.Config, error)</li> <li>func (r *ConfigRepository) FindAllByProviderAndDependsOn(provider, service, source string) ([]*entity.Config, error)</li> <li>func (r *ConfigRepository) FindAllByServiceAndProvider(provider, service string) ([]*entity.Config, error)</li> <li>func (r *ConfigRepository) FindAllByServiceAndProviderAndActive(service, provider string, active bool) ([]*entity.Config, error)</li> <li>func (r *ConfigRepository) FindAllByServiceAndSourceAndProvider(service, source, provider string) ([]*entity.Config, error)</li> <li>func (r *ConfigRepository) FindAllBySourceAndProvider(provider, source string) ([]*entity.Config, error)</li> <li>func (r *ConfigRepository) FindByID(id string) (*entity.Config, error)</li> <li>func (r *ConfigRepository) Update(config *entity.Config) error</li> </ul>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/docs/godoc/#type-configrepository","title":"type ConfigRepository","text":"<p>ConfigRepository manages the operations on the Config collection in MongoDB.</p> <pre><code>type ConfigRepository struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/docs/godoc/#func-newconfigrepository","title":"func NewConfigRepository","text":"<pre><code>func NewConfigRepository(client *mongo.Client, database string) *ConfigRepository\n</code></pre> <p>NewConfigRepository creates a new ConfigRepository instance. It initializes the collection for the specified database.</p> <p>Parameters:</p> <ul> <li>client: The MongoDB client.</li> <li>database: The name of the database.</li> </ul> <p>Returns:</p> <ul> <li>A pointer to a ConfigRepository instance.</li> </ul> <p>Example:</p> <pre><code>client := mongo.Connect(context.Background(), options.Client().ApplyURI(\"mongodb://localhost:27017\"))\nrepository := NewConfigRepository(client, \"testdb\")\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/docs/godoc/#func-configrepository-create","title":"func (*ConfigRepository) Create","text":"<pre><code>func (r *ConfigRepository) Create(config *entity.Config) error\n</code></pre> <p>Create inserts a new Config document into the collection.</p> <p>Parameters:</p> <ul> <li>config: The Config entity to be inserted.</li> </ul> <p>Returns:</p> <ul> <li>An error if the document already exists or cannot be inserted.</li> </ul> <p>Example:</p> <pre><code>err := repository.Create(newConfig)\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/docs/godoc/#func-configrepository-delete","title":"func (*ConfigRepository) Delete","text":"<pre><code>func (r *ConfigRepository) Delete(id string) error\n</code></pre> <p>Delete removes a Config document from the collection by its ID.</p> <p>Parameters:</p> <ul> <li>id: The ID of the Config document to be deleted.</li> </ul> <p>Returns:</p> <ul> <li>An error if the document is not found or cannot be deleted.</li> </ul> <p>Example:</p> <pre><code>err := repository.Delete(\"60d5ec49e17e8e304c8f5310\")\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/docs/godoc/#func-configrepository-findall","title":"func (*ConfigRepository) FindAll","text":"<pre><code>func (r *ConfigRepository) FindAll() ([]*entity.Config, error)\n</code></pre> <p>FindAll retrieves all Config documents in the collection.</p> <p>Returns:</p> <ul> <li>A slice of pointers to Config entities.</li> <li>An error if the query fails.</li> </ul> <p>Example:</p> <pre><code>configs, err := repository.FindAll()\nif err != nil {\n    log.Fatal(err)\n}\nfor _, config := range configs {\n    fmt.Printf(\"Config: %+v\\n\", config)\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/docs/godoc/#func-configrepository-findallbyprovideranddependson","title":"func (*ConfigRepository) FindAllByProviderAndDependsOn","text":"<pre><code>func (r *ConfigRepository) FindAllByProviderAndDependsOn(provider, service, source string) ([]*entity.Config, error)\n</code></pre> <p>FindAllByProviderAndDependsOn retrieves all Config documents that have dependencies matching the given service and source.</p> <p>Parameters:</p> <ul> <li>service: The service name to match in dependencies.</li> <li>source: The source name to match in dependencies.</li> </ul> <p>Returns:</p> <ul> <li>A slice of pointers to Config entities.</li> <li>An error if the query fails.</li> </ul> <p>Example:</p> <pre><code>configs, err := repository.FindAllByProviderAndDependsOn(\"provider\", \"dep_service\", \"dep_source\")\nif err != nil {\n    log.Fatal(err)\n}\nfor _, config := range configs {\n    fmt.Printf(\"Config: %+v\\n\", config)\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/docs/godoc/#func-configrepository-findallbyserviceandprovider","title":"func (*ConfigRepository) FindAllByServiceAndProvider","text":"<pre><code>func (r *ConfigRepository) FindAllByServiceAndProvider(provider, service string) ([]*entity.Config, error)\n</code></pre> <p>FindAllByServiceAndProvider retrieves all Config documents that match the given provider and service.</p> <p>Parameters:</p> <ul> <li>service: The service name to match.</li> </ul> <p>Returns:</p> <ul> <li>A slice of pointers to Config entities.</li> <li>An error if the query fails.</li> </ul> <p>Example:</p> <pre><code>configs, err := repository.FindAllByServiceAndProvider(\"myprovider\", \"myservice\")\nif err != nil {\n    log.Fatal(err)\n}\nfor _, config := range configs {\n    fmt.Printf(\"Config: %+v\\n\", config)\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/docs/godoc/#func-configrepository-findallbyserviceandproviderandactive","title":"func (*ConfigRepository) FindAllByServiceAndProviderAndActive","text":"<pre><code>func (r *ConfigRepository) FindAllByServiceAndProviderAndActive(service, provider string, active bool) ([]*entity.Config, error)\n</code></pre> <p>FindAllByServiceAndProviderAndActive retrieves all Config documents that match the given service, provider, and active status.</p> <p>Parameters:</p> <ul> <li>service: The service name to match.</li> <li>provider: The provider name to match.</li> <li>active: The active status to match.</li> </ul> <p>Returns:</p> <ul> <li>A slice of pointers to Config entities.</li> <li>An error if the query fails.</li> </ul> <p>Example:</p> <pre><code>configs, err := repository.FindAllByServiceAndProviderAndActive(\"myservice\", \"myprovider\", true)\nif err != nil {\n    log.Fatal(err)\n}\nfor _, config := range configs {\n    fmt.Printf(\"Config: %+v\\n\", config)\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/docs/godoc/#func-configrepository-findallbyserviceandsourceandprovider","title":"func (*ConfigRepository) FindAllByServiceAndSourceAndProvider","text":"<pre><code>func (r *ConfigRepository) FindAllByServiceAndSourceAndProvider(service, source, provider string) ([]*entity.Config, error)\n</code></pre> <p>FindAllByServiceAndSourceAndProvider retrieves all Config documents that match the given service, source, and provider.</p> <p>Parameters:</p> <ul> <li>service: The service name to match.</li> <li>source: The source name to match.</li> <li>provider: The provider name to match.</li> </ul> <p>Returns:</p> <ul> <li>A slice of pointers to Config entities.</li> <li>An error if the query fails.</li> </ul> <p>Example:</p> <pre><code>configs, err := repository.FindAllByServiceAndSourceAndProvider(\"myservice\", \"mysource\", \"myprovider\")\nif err != nil {\n    log.Fatal(err)\n}\nfor _, config := range configs {\n    fmt.Printf(\"Config: %+v\\n\", config)\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/docs/godoc/#func-configrepository-findallbysourceandprovider","title":"func (*ConfigRepository) FindAllBySourceAndProvider","text":"<pre><code>func (r *ConfigRepository) FindAllBySourceAndProvider(provider, source string) ([]*entity.Config, error)\n</code></pre> <p>FindAllBySourceAndProvider retrieves all Config documents that match the given provider and source.</p> <p>Parameters:</p> <ul> <li>source: The source name to match.</li> </ul> <p>Returns:</p> <ul> <li>A slice of pointers to Config entities.</li> <li>An error if the query fails.</li> </ul> <p>Example:</p> <pre><code>configs, err := repository.FindAllBySourceAndProvider(\"myprovider\", \"mysource\")\nif err != nil {\n    log.Fatal(err)\n}\nfor _, config := range configs {\n    fmt.Printf(\"Config: %+v\\n\", config)\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/docs/godoc/#func-configrepository-findbyid","title":"func (*ConfigRepository) FindByID","text":"<pre><code>func (r *ConfigRepository) FindByID(id string) (*entity.Config, error)\n</code></pre> <p>FindByID retrieves a single Config document by its ID.</p> <p>Parameters:</p> <ul> <li>id: The ID of the Config document.</li> </ul> <p>Returns:</p> <ul> <li>A pointer to the Config entity.</li> <li>An error if the document is not found or cannot be decoded.</li> </ul> <p>Example:</p> <pre><code>config, err := repository.FindByID(\"60d5ec49e17e8e304c8f5310\")\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/domain/repositories/database/mongodb/config-vault/docs/godoc/#func-configrepository-update","title":"func (*ConfigRepository) Update","text":"<pre><code>func (r *ConfigRepository) Update(config *entity.Config) error\n</code></pre> <p>Update modifies an existing Config document in the collection.</p> <p>Parameters:</p> <ul> <li>config: The Config entity with updated data.</li> </ul> <p>Returns:</p> <ul> <li>An error if the document is not found or cannot be updated.</li> </ul> <p>Example:</p> <pre><code>err := repository.Update(updatedConfig)\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/ddd/dtos/config-vault/","title":"config-vault/dto","text":"<p><code>config-vault/dto</code> is a Go library that provides data transfer objects (DTOs) for managing configuration data within a system. This library includes structures for input and output DTOs, facilitating the transfer and validation of configuration data.</p>"},{"location":"reference/libs/golang/ddd/dtos/config-vault/#features","title":"Features","text":"<ul> <li>Define DTOs for configuration input and output.</li> <li>Facilitate data transfer between different components of the system.</li> <li>Ensure consistency and validation of configuration data.</li> </ul>"},{"location":"reference/libs/golang/ddd/dtos/config-vault/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/ddd/dtos/config-vault/#defining-configuration-dtos","title":"Defining Configuration DTOs","text":"<p>The <code>ConfigDTO</code> struct represents a configuration data transfer object with attributes such as service, source, provider, and dependencies.</p>"},{"location":"reference/libs/golang/ddd/dtos/config-vault/#output-dto","title":"Output DTO","text":"<p>The <code>outputdto.ConfigDTO</code> struct is used to represent configuration data for output purposes.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/ddd/dtos/config-vault/outputdto\"\n    shareddto \"libs/golang/ddd/dtos/config-vault/shared\"\n)\n\nfunc main() {\n    config := outputdto.ConfigDTO{\n        ID:              \"12345\",\n        Active:          true,\n        Service:         \"exampleService\",\n        Source:          \"exampleSource\",\n        Provider:        \"exampleProvider\",\n        DependsOn:       []shareddto.JobDependenciesDTO{\n            {Service: \"dependencyService\", Source: \"dependencySource\"},\n        },\n        ConfigVersionID: \"v1\",\n        CreatedAt:       \"2023-06-08 12:00:00\",\n        UpdatedAt:       \"2023-06-09 12:00:00\",\n    }\n\n    fmt.Printf(\"Output ConfigDTO: %+v\\n\", config)\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/dtos/config-vault/#input-dto","title":"Input DTO","text":"<p>The <code>inputdto.ConfigDTO</code> struct is used to represent configuration data for input purposes.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/ddd/dtos/config-vault/inputdto\"\n    shareddto \"libs/golang/ddd/dtos/config-vault/shared\"\n)\n\nfunc main() {\n    config := inputdto.ConfigDTO{\n        Active:    true,\n        Service:   \"exampleService\",\n        Source:    \"exampleSource\",\n        Provider:  \"exampleProvider\",\n        DependsOn: []shareddto.JobDependenciesDTO{\n            {Service: \"dependencyService\", Source: \"dependencySource\"},\n        },\n    }\n\n    fmt.Printf(\"Input ConfigDTO: %+v\\n\", config)\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/dtos/config-vault/#shared-dto","title":"Shared DTO","text":"<p>The <code>shareddto.JobDependenciesDTO</code> struct is used to represent dependencies between services.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    shareddto \"libs/golang/ddd/dtos/config-vault/shared\"\n)\n\nfunc main() {\n    dependency := shareddto.JobDependenciesDTO{\n        Service: \"exampleService\",\n        Source:  \"exampleSource\",\n    }\n\n    fmt.Printf(\"JobDependenciesDTO: %+v\\n\", dependency)\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/dtos/config-vault/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/ddd/dtos/config-vault/docs/godoc/#inputdto","title":"inputdto","text":"<pre><code>import \"libs/golang/ddd/dtos/config-vault/input\"\n</code></pre>"},{"location":"reference/libs/golang/ddd/dtos/config-vault/docs/godoc/#index","title":"Index","text":"<ul> <li>type ConfigDTO</li> </ul>"},{"location":"reference/libs/golang/ddd/dtos/config-vault/docs/godoc/#type-configdto","title":"type ConfigDTO","text":"<p>ConfigDTO represents the data transfer object for configuration input. It includes the necessary details required for creating or updating a configuration, such as service details, source, provider, and dependencies.</p> <pre><code>type ConfigDTO struct {\n    Active    bool                           `json:\"active\"`     // Active indicates whether the configuration should be activated.\n    Service   string                         `json:\"service\"`    // Service represents the name of the service for which the configuration is created.\n    Source    string                         `json:\"source\"`     // Source indicates the origin or source of the configuration.\n    Provider  string                         `json:\"provider\"`   // Provider specifies the provider of the configuration.\n    DependsOn []shareddto.JobDependenciesDTO `json:\"depends_on\"` // DependsOn lists the dependencies required for the configuration, represented by JobDependenciesDTO.\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/dtos/config-vault/docs/godoc/#outputdto","title":"outputdto","text":"<pre><code>import \"libs/golang/ddd/dtos/config-vault/output\"\n</code></pre>"},{"location":"reference/libs/golang/ddd/dtos/config-vault/docs/godoc/#index_1","title":"Index","text":"<ul> <li>type ConfigDTO</li> </ul>"},{"location":"reference/libs/golang/ddd/dtos/config-vault/docs/godoc/#type-configdto_1","title":"type ConfigDTO","text":"<p>ConfigDTO represents the data transfer object for configuration output. It contains detailed information about the configuration, including its status, service details, dependencies, and timestamps for creation and updates.</p> <pre><code>type ConfigDTO struct {\n    ID              string                         `json:\"id\"`                // ID is the unique identifier of the configuration.\n    Active          bool                           `json:\"active\"`            // Active indicates whether the configuration is currently active.\n    Service         string                         `json:\"service\"`           // Service represents the name of the service associated with the configuration.\n    Source          string                         `json:\"source\"`            // Source indicates the origin or source of the configuration.\n    Provider        string                         `json:\"provider\"`          // Provider specifies the provider of the configuration.\n    DependsOn       []shareddto.JobDependenciesDTO `json:\"depends_on\"`        // DependsOn lists the dependencies of the configuration, represented by JobDependenciesDTO.\n    ConfigVersionID string                         `json:\"config_version_id\"` // ConfigVersionID is the identifier of the configuration version.\n    CreatedAt       string                         `json:\"created_at\"`        // CreatedAt is the timestamp when the configuration was created.\n    UpdatedAt       string                         `json:\"updated_at\"`        // UpdatedAt is the timestamp when the configuration was last updated.\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/dtos/config-vault/docs/godoc/#shareddto","title":"shareddto","text":"<pre><code>import \"libs/golang/ddd/dtos/config-vault/shared\"\n</code></pre>"},{"location":"reference/libs/golang/ddd/dtos/config-vault/docs/godoc/#index_2","title":"Index","text":"<ul> <li>type JobDependenciesDTO</li> </ul>"},{"location":"reference/libs/golang/ddd/dtos/config-vault/docs/godoc/#type-jobdependenciesdto","title":"type JobDependenciesDTO","text":"<p>JobDependenciesDTO represents the data transfer object for job dependencies. It includes the service and source details that are dependent on each other.</p> <pre><code>type JobDependenciesDTO struct {\n    Service string `json:\"service\"` // Service represents the name of the dependent service.\n    Source  string `json:\"source\"`  // Source indicates the origin or source of the dependency.\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/ddd/shared/type-tools/custom-types-converter/config-vault/","title":"config-vault/converter","text":"<p><code>config-vault/converter</code> is a Go library that provides utility functions to convert between data transfer objects (DTOs) and entities within the configuration vault domain. This library facilitates the transformation of job dependency data structures between different layers of the application.</p>"},{"location":"reference/libs/golang/ddd/shared/type-tools/custom-types-converter/config-vault/#features","title":"Features","text":"<ul> <li>Convert job dependencies from DTOs to entities.</li> <li>Convert job dependencies from entities to DTOs.</li> <li>Convert job dependencies from DTOs to a map.</li> </ul>"},{"location":"reference/libs/golang/ddd/shared/type-tools/custom-types-converter/config-vault/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/ddd/shared/type-tools/custom-types-converter/config-vault/#converting-job-dependencies-dtos-to-entities","title":"Converting Job Dependencies DTOs to Entities","text":"<p>The <code>ConvertJobDependenciesDTOToEntity</code> function converts a slice of <code>JobDependenciesDTO</code> to a slice of <code>JobDependencies</code> entities.</p>"},{"location":"reference/libs/golang/ddd/shared/type-tools/custom-types-converter/config-vault/#example","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/ddd/domain/entities/config-vault/entity\"\n    \"libs/golang/ddd/dtos/config-vault/shared\"\n    \"libs/golang/ddd/domain/converter\"\n)\n\nfunc main() {\n    dtoDeps := []shareddto.JobDependenciesDTO{\n        {\n            Service: \"service1\",\n            Source:  \"source1\",\n        },\n        {\n            Service: \"service2\",\n            Source:  \"source2\",\n        },\n    }\n\n    entityDeps := converter.ConvertJobDependenciesDTOToEntity(dtoDeps)\n    fmt.Printf(\"Converted entities: %+v\\n\", entityDeps)\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/shared/type-tools/custom-types-converter/config-vault/#converting-job-dependencies-entities-to-dtos","title":"Converting Job Dependencies Entities to DTOs","text":"<p>The <code>ConvertJobDependenciesEntityToDTO</code> function converts a slice of <code>JobDependencies</code> entities to a slice of <code>JobDependenciesDTO</code>.</p>"},{"location":"reference/libs/golang/ddd/shared/type-tools/custom-types-converter/config-vault/#example_1","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/ddd/domain/entities/config-vault/entity\"\n    \"libs/golang/ddd/dtos/config-vault/shared\"\n    \"libs/golang/ddd/domain/converter\"\n)\n\nfunc main() {\n    entityDeps := []entity.JobDependencies{\n        {\n            Service: \"service1\",\n            Source:  \"source1\",\n        },\n        {\n            Service: \"service2\",\n            Source:  \"source2\",\n        },\n    }\n\n    dtoDeps := converter.ConvertJobDependenciesEntityToDTO(entityDeps)\n    fmt.Printf(\"Converted DTOs: %+v\\n\", dtoDeps)\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/shared/type-tools/custom-types-converter/config-vault/#converting-job-dependencies-dtos-to-a-map","title":"Converting Job Dependencies DTOs to a Map","text":"<p>The <code>ConvertJobDependenciesDTOToMap</code> function converts a slice of <code>JobDependenciesDTO</code> to a map of <code>JobDependencies</code> entities.</p>"},{"location":"reference/libs/golang/ddd/shared/type-tools/custom-types-converter/config-vault/#example_2","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/ddd/domain/entities/config-vault/entity\"\n    \"libs/golang/ddd/dtos/config-vault/shared\"\n    \"libs/golang/ddd/domain/converter\"\n)\n\nfunc main() {\n    dtoDeps := []shareddto.JobDependenciesDTO{\n        {\n            Service: \"service1\",\n            Source:  \"source1\",\n        },\n        {\n            Service: \"service2\",\n            Source:  \"source2\",\n        },\n    }\n\n    entityMap := converter.ConvertJobDependenciesDTOToMap(dtoDeps)\n    fmt.Printf(\"Converted entity map: %+v\\n\", entityMap)\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/shared/type-tools/custom-types-converter/config-vault/#testing","title":"Testing","text":"<p>To run the tests for the <code>converter</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-ddd-shared-type-tools-custom-types-converter-config-vault\n</code></pre>"},{"location":"reference/libs/golang/ddd/shared/type-tools/custom-types-converter/config-vault/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/ddd/shared/type-tools/custom-types-converter/config-vault/docs/godoc/#converter","title":"converter","text":"<pre><code>import \"libs/golang/ddd/shared/type-tools/custom-types-converter/config-vault/converter\"\n</code></pre>"},{"location":"reference/libs/golang/ddd/shared/type-tools/custom-types-converter/config-vault/docs/godoc/#index","title":"Index","text":"<ul> <li>func ConvertJobDependenciesDTOToEntity(dependsOnDTO []shareddto.JobDependenciesDTO) []entity.JobDependencies</li> <li>func ConvertJobDependenciesDTOToMap(dependsOnDTO []shareddto.JobDependenciesDTO) []map[string]interface{}</li> <li>func ConvertJobDependenciesEntityToDTO(dependsOn []entity.JobDependencies) []shareddto.JobDependenciesDTO</li> </ul>"},{"location":"reference/libs/golang/ddd/shared/type-tools/custom-types-converter/config-vault/docs/godoc/#func-convertjobdependenciesdtotoentity","title":"func ConvertJobDependenciesDTOToEntity","text":"<pre><code>func ConvertJobDependenciesDTOToEntity(dependsOnDTO []shareddto.JobDependenciesDTO) []entity.JobDependencies\n</code></pre> <p>ConvertJobDependenciesDTOToEntity converts a slice of JobDependenciesDTO to a slice of JobDependencies entities. This function iterates over each JobDependenciesDTO and maps its fields to the corresponding JobDependencies entity fields.</p> <p>Parameters:</p> <pre><code>dependsOnDTO: A slice of shareddto.JobDependenciesDTO to be converted.\n</code></pre> <p>Returns:</p> <pre><code>A slice of entity.JobDependencies containing the converted data.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/shared/type-tools/custom-types-converter/config-vault/docs/godoc/#func-convertjobdependenciesdtotomap","title":"func ConvertJobDependenciesDTOToMap","text":"<pre><code>func ConvertJobDependenciesDTOToMap(dependsOnDTO []shareddto.JobDependenciesDTO) []map[string]interface{}\n</code></pre> <p>ConvertJobDependenciesDTOToMap converts a slice of JobDependenciesDTO to a map of JobDependencies entities. This function iterates over each JobDependenciesDTO and maps its fields to the corresponding JobDependencies entity fields.</p> <p>Parameters:</p> <pre><code>dependsOnDTO: A slice of shareddto.JobDependenciesDTO to be converted.\n</code></pre> <p>Returns:</p> <pre><code>A map of entity.JobDependencies containing the converted data.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/shared/type-tools/custom-types-converter/config-vault/docs/godoc/#func-convertjobdependenciesentitytodto","title":"func ConvertJobDependenciesEntityToDTO","text":"<pre><code>func ConvertJobDependenciesEntityToDTO(dependsOn []entity.JobDependencies) []shareddto.JobDependenciesDTO\n</code></pre> <p>ConvertJobDependenciesEntityToDTO converts a slice of JobDependencies entities to a slice of JobDependenciesDTO. This function iterates over each JobDependencies entity and maps its fields to the corresponding JobDependenciesDTO fields.</p> <p>Parameters:</p> <pre><code>dependsOn: A slice of entity.JobDependencies to be converted.\n</code></pre> <p>Returns:</p> <pre><code>A slice of shareddto.JobDependenciesDTO containing the converted data.\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/ddd/shared/type-tools/regular-types-converter/","title":"regular-types-converter","text":"<p><code>regular-types-converter</code> is a Go library that provides utilities for converting built-in types to various entity types. This library is designed to be flexible and easy to use, allowing you to convert data into entity types without directly importing those types.</p>"},{"location":"reference/libs/golang/ddd/shared/type-tools/regular-types-converter/#features","title":"Features","text":"<ul> <li>Convert <code>map[string]interface{}</code> to any struct type.</li> <li>Convert an array of <code>map[string]interface{}</code> to an array of the specified entity type.</li> <li>convert an entity type to a <code>map[string]interface{}</code></li> <li>Decouples conversion logic from entity types.</li> <li>Makes code more modular and maintainable.</li> </ul>"},{"location":"reference/libs/golang/ddd/shared/type-tools/regular-types-converter/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/ddd/shared/type-tools/regular-types-converter/#convert-mapstringinterface-to-entity","title":"Convert <code>map[string]interface{}</code> to Entity","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n\n    \"libs/golang/ddd/domain/entities/config-vault/entity\"\n    \"libs/golang/ddd/shared/type-tools/regular-types-converter/conversion\"\n)\n\nfunc main() {\n    data := map[string]interface{}{\n        \"service\": \"example-service\",\n        \"source\":  \"example-source\",\n    }\n\n    entity, err := regulartypetool.ConvertFromMapStringToEntity(reflect.TypeOf(entity.JobDependencies{}), data)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    jobDependencies := entity.(entity.JobDependencies)\n    fmt.Println(\"JobDependencies:\", jobDependencies)\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/shared/type-tools/regular-types-converter/#convert-array-of-mapstringinterface-to-array-of-entities","title":"Convert Array of <code>map[string]interface{}</code> to Array of Entities","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n\n    \"libs/golang/ddd/domain/entities/config-vault/entity\"\n    \"libs/golang/ddd/shared/type-tools/regular-types-converter/conversion\"\n)\n\nfunc main() {\n    dataArray := []map[string]interface{}{\n        {\n            \"service\": \"example-service-1\",\n            \"source\":  \"example-source-1\",\n        },\n        {\n            \"service\": \"example-service-2\",\n            \"source\":  \"example-source-2\",\n        },\n    }\n\n    entities, err := regulartypetool.ConvertFromArrayMapStringToEntities(reflect.TypeOf(entity.JobDependencies{}), dataArray)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    for _, e := range entities {\n        entityType := e.(entity.JobDependencies)\n        fmt.Println(\"JobDependencies:\", entityType)\n    }\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/shared/type-tools/regular-types-converter/#convert-entity-to-mapstringinterface","title":"Convert Entity to <code>map[string]interface{}</code>","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"libs/golang/ddd/shared/type-tools/regular-types-converter/conversion\"\n)\n\ntype JobDependencies struct {\n    Service string `bson:\"service\"`\n    Source  string `bson:\"source\"`\n}\n\nfunc main() {\n    jobDependencies := JobDependencies{\n        Service: \"example-service\",\n        Source:  \"example-source\",\n    }\n\n    data, err := regulartypetool.ConvertFromEntityToMapString(jobDependencies)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    fmt.Println(\"Data:\", data)\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/shared/type-tools/regular-types-converter/#testing","title":"Testing","text":"<p>To run the tests for the <code>regular-types-converter</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-ddd-shared-type-tools-regular-types-converter\n</code></pre>"},{"location":"reference/libs/golang/ddd/shared/type-tools/regular-types-converter/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/ddd/shared/type-tools/regular-types-converter/docs/godoc/#regulartypetool","title":"regulartypetool","text":"<pre><code>import \"libs/golang/ddd/shared/type-tools/regular-types-converter/conversion\"\n</code></pre>"},{"location":"reference/libs/golang/ddd/shared/type-tools/regular-types-converter/docs/godoc/#index","title":"Index","text":"<ul> <li>func ConvertFromArrayMapStringToEntities(entityType reflect.Type, dataArray []map[string]interface{}) ([]interface{}, error)</li> <li>func ConvertFromEntityToMapString(entity interface{}) (map[string]interface{}, error)</li> <li>func ConvertFromMapStringToEntity(entityType reflect.Type, data map[string]interface{}) (interface{}, error)</li> </ul>"},{"location":"reference/libs/golang/ddd/shared/type-tools/regular-types-converter/docs/godoc/#func-convertfromarraymapstringtoentities","title":"func ConvertFromArrayMapStringToEntities","text":"<pre><code>func ConvertFromArrayMapStringToEntities(entityType reflect.Type, dataArray []map[string]interface{}) ([]interface{}, error)\n</code></pre> <p>ConvertFromArrayMapStringToEntities converts an array of map[string]interface{} to an array of the specified entity type.</p> <p></p>"},{"location":"reference/libs/golang/ddd/shared/type-tools/regular-types-converter/docs/godoc/#func-convertfromentitytomapstring","title":"func ConvertFromEntityToMapString","text":"<pre><code>func ConvertFromEntityToMapString(entity interface{}) (map[string]interface{}, error)\n</code></pre>"},{"location":"reference/libs/golang/ddd/shared/type-tools/regular-types-converter/docs/godoc/#func-convertfrommapstringtoentity","title":"func ConvertFromMapStringToEntity","text":"<pre><code>func ConvertFromMapStringToEntity(entityType reflect.Type, data map[string]interface{}) (interface{}, error)\n</code></pre> <p>ConvertFromMapStringToEntity converts a map[string]interface{} to the specified entity type. The entityType parameter should be the reflect.TypeOf() value of the target entity.</p> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/","title":"config-vault/usecase","text":"<p><code>config-vault/usecase</code> is a Go library that provides various use cases for managing configuration entities within a system. This library includes functionalities for creating, updating, deleting, and querying configurations based on different attributes.</p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/#features","title":"Features","text":"<ul> <li>Create, update, delete, and list configuration entities.</li> <li>Query configurations by service, source, provider, and other attributes.</li> <li>Validate and convert configuration data between different formats.</li> </ul>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/ddd/usecases/config-vault/#creating-a-configuration","title":"Creating a Configuration","text":"<p>The <code>CreateConfigUseCase</code> struct provides methods to create a new configuration entity and save it using the repository.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/ddd/domain/entities/config-vault/entity\"\n    inputdto \"libs/golang/ddd/dtos/config-vault/input\"\n    outputdto \"libs/golang/ddd/dtos/config-vault/output\"\n    \"libs/golang/ddd/domain/repositories/database/mongodb/config-vault/repository\"\n    \"libs/golang/ddd/usecases/config-vault/usecase\"\n    \"go.mongodb.org/mongo-driver/mongo\"\n    \"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\nfunc main() {\n    clientOptions := options.Client().ApplyURI(\"mongodb://localhost:27017\")\n    client, err := mongo.Connect(context.Background(), clientOptions)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    repo := repository.NewConfigRepository(client, \"testdb\")\n    createUseCase := usecase.NewCreateConfigUseCase(repo)\n\n    input := inputdto.ConfigDTO{\n        Active:   true,\n        Service:  \"exampleService\",\n        Source:   \"exampleSource\",\n        Provider: \"exampleProvider\",\n        DependsOn: []shareddto.JobDependenciesDTO{\n            {Service: \"dependencyService\", Source: \"dependencySource\"},\n        },\n    }\n\n    output, err := createUseCase.Execute(input)\n    if err != nil {\n        fmt.Println(\"Error creating config:\", err)\n        return\n    }\n\n    fmt.Printf(\"Config created: %+v\\n\", output)\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/#updating-a-configuration","title":"Updating a Configuration","text":"<p>The <code>UpdateConfigUseCase</code> struct provides methods to update an existing configuration entity and save it using the repository.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/ddd/domain/entities/config-vault/entity\"\n    inputdto \"libs/golang/ddd/dtos/config-vault/input\"\n    outputdto \"libs/golang/ddd/dtos/config-vault/output\"\n    \"libs/golang/ddd/domain/repositories/database/mongodb/config-vault/repository\"\n    \"libs/golang/ddd/usecases/config-vault/usecase\"\n    \"go.mongodb.org/mongo-driver/mongo\"\n    \"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\nfunc main() {\n    clientOptions := options.Client().ApplyURI(\"mongodb://localhost:27017\")\n    client, err := mongo.Connect(context.Background(), clientOptions)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    repo := repository.NewConfigRepository(client, \"testdb\")\n    updateUseCase := usecase.NewUpdateConfigUseCase(repo)\n\n    input := inputdto.ConfigDTO{\n        Active:   true,\n        Service:  \"exampleService\",\n        Source:   \"exampleSource\",\n        Provider: \"exampleProvider\",\n        DependsOn: []shareddto.JobDependenciesDTO{\n            {Service: \"dependencyService\", Source: \"dependencySource\"},\n        },\n    }\n\n    output, err := updateUseCase.Execute(input)\n    if err != nil {\n        fmt.Println(\"Error updating config:\", err)\n        return\n    }\n\n    fmt.Printf(\"Config updated: %+v\\n\", output)\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/#deleting-a-configuration","title":"Deleting a Configuration","text":"<p>The <code>DeleteConfigUseCase</code> struct provides methods to delete an existing configuration entity by its ID.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/ddd/domain/repositories/database/mongodb/config-vault/repository\"\n    \"libs/golang/ddd/usecases/config-vault/usecase\"\n    \"go.mongodb.org/mongo-driver/mongo\"\n    \"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\nfunc main() {\n    clientOptions := options.Client().ApplyURI(\"mongodb://localhost:27017\")\n    client, err := mongo.Connect(context.Background(), clientOptions)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    repo := repository.NewConfigRepository(client, \"testdb\")\n    deleteUseCase := usecase.NewDeleteConfigUseCase(repo)\n\n    err = deleteUseCase.Execute(\"exampleID\")\n    if err != nil {\n        fmt.Println(\"Error deleting config:\", err)\n        return\n    }\n\n    fmt.Println(\"Config deleted successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/#listing-configurations-by-service","title":"Listing Configurations by Service","text":"<p>The <code>ListAllByServiceConfigUseCase</code> struct provides methods to list all configurations by a specific service.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/ddd/domain/repositories/database/mongodb/config-vault/repository\"\n    \"libs/golang/ddd/usecases/config-vault/usecase\"\n    \"go.mongodb.org/mongo-driver/mongo\"\n    \"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\nfunc main() {\n    clientOptions := options.Client().ApplyURI(\"mongodb://localhost:27017\")\n    client, err := mongo.Connect(context.Background(), clientOptions)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    repo := repository.NewConfigRepository(client, \"testdb\")\n    listUseCase := usecase.NewListAllByServiceConfigUseCase(repo)\n\n    configs, err := listUseCase.Execute(\"exampleService\")\n    if err != nil {\n        fmt.Println(\"Error listing configs:\", err)\n        return\n    }\n\n    for _, config := range configs {\n        fmt.Printf(\"Config: %+v\\n\", config)\n    }\n}\n</code></pre>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/#testing","title":"Testing","text":"<p>To run the tests for the <code>usecase</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-ddd-usecases-config-vault\n</code></pre>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/#use-cases","title":"Use Cases","text":"<ul> <li>CreateConfigUseCase: Create a new configuration entity.</li> <li>UpdateConfigUseCase: Update an existing configuration entity.</li> <li>DeleteConfigUseCase: Delete a configuration entity by its ID.</li> <li>ListAllByServiceConfigUseCase: List all configurations by a specific service.</li> <li>ListAllConfigUseCase: List all configurations.</li> <li>ListOneByIDConfigUseCase: Retrieve a configuration by its ID.</li> <li>ListAllByDependsOnConfigUseCase: List all configurations by their dependencies.</li> <li>ListAllByServiceAndSourceConfigUseCase: List all configurations by service and source.</li> <li>ListAllByServiceAndProviderAndActiveConfigUseCase: List all configurations by service, provider, and active status.</li> <li>ListAllByServiceAndSourceAndProviderConfigUseCase: List all configurations by service, source, and provider.</li> <li>ListAllBySourceConfigUseCase: List all configurations by source.</li> </ul>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/#errors","title":"Errors","text":"<ul> <li><code>ErrInvalidID</code>: Returned when the ID of a <code>Config</code> is invalid.</li> <li><code>ErrInvalidService</code>: Returned when the service of a <code>Config</code> is invalid.</li> <li><code>ErrInvalidSource</code>: Returned when the source of a <code>Config</code> is invalid.</li> <li><code>ErrInvalidProvider</code>: Returned when the provider of a <code>Config</code> is invalid.</li> <li><code>ErrInvalidConfigVersionID</code>: Returned when the config version ID of a <code>Config</code> is invalid.</li> <li><code>ErrInvalidCreatedAt</code>: Returned when the created at timestamp of a <code>Config</code> is invalid.</li> </ul>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#usecase","title":"usecase","text":"<pre><code>import \"libs/golang/ddd/usecases/config-vault/usecase\"\n</code></pre>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#index","title":"Index","text":"<ul> <li>type CreateConfigUseCase</li> <li>func NewCreateConfigUseCase(configRepository entity.ConfigRepositoryInterface) *CreateConfigUseCase</li> <li>func (uc *CreateConfigUseCase) Execute(input inputdto.ConfigDTO) (outputdto.ConfigDTO, error)</li> <li>type DeleteConfigUseCase</li> <li>func NewDeleteConfigUseCase(configRepository entity.ConfigRepositoryInterface) *DeleteConfigUseCase</li> <li>func (uc *DeleteConfigUseCase) Execute(id string) error</li> <li>type ListAllByProviderAndDependsOnConfigUseCase</li> <li>func NewListAllByProviderAndDependsOnConfigUseCase(configRepository entity.ConfigRepositoryInterface) *ListAllByProviderAndDependsOnConfigUseCase</li> <li>func (uc *ListAllByProviderAndDependsOnConfigUseCase) Execute(provider, service, source string) ([]outputdto.ConfigDTO, error)</li> <li>type ListAllByServiceAndProviderAndActiveConfigUseCase</li> <li>func NewListAllByServiceAndProviderAndActiveConfigUseCase(configRepository entity.ConfigRepositoryInterface) *ListAllByServiceAndProviderAndActiveConfigUseCase</li> <li>func (uc *ListAllByServiceAndProviderAndActiveConfigUseCase) Execute(service, provider string, active bool) ([]outputdto.ConfigDTO, error)</li> <li>type ListAllByServiceAndProviderConfigUseCase</li> <li>func NewListAllByServiceAndProviderConfigUseCase(configRepository entity.ConfigRepositoryInterface) *ListAllByServiceAndProviderConfigUseCase</li> <li>func (uc *ListAllByServiceAndProviderConfigUseCase) Execute(provider, service string) ([]outputdto.ConfigDTO, error)</li> <li>type ListAllByServiceAndSourceAndProviderConfigUseCase</li> <li>func NewListAllByServiceAndSourceAndProviderConfigUseCase(configRepository entity.ConfigRepositoryInterface) *ListAllByServiceAndSourceAndProviderConfigUseCase</li> <li>func (uc *ListAllByServiceAndSourceAndProviderConfigUseCase) Execute(service, source, provider string) ([]outputdto.ConfigDTO, error)</li> <li>type ListAllBySourceAndProviderConfigUseCase</li> <li>func NewListAllBySourceAndProviderConfigUseCase(configRepository entity.ConfigRepositoryInterface) *ListAllBySourceAndProviderConfigUseCase</li> <li>func (uc *ListAllBySourceAndProviderConfigUseCase) Execute(provider, source string) ([]outputdto.ConfigDTO, error)</li> <li>type ListAllConfigUseCase</li> <li>func NewListAllConfigUseCase(configRepository entity.ConfigRepositoryInterface) *ListAllConfigUseCase</li> <li>func (uc *ListAllConfigUseCase) Execute() ([]outputdto.ConfigDTO, error)</li> <li>type ListOneByIDConfigUseCase</li> <li>func NewListOneByIDConfigUseCase(configRepository entity.ConfigRepositoryInterface) *ListOneByIDConfigUseCase</li> <li>func (uc *ListOneByIDConfigUseCase) Execute(id string) (outputdto.ConfigDTO, error)</li> <li>type UpdateConfigUseCase</li> <li>func NewUpdateConfigUseCase(configRepository entity.ConfigRepositoryInterface) *UpdateConfigUseCase</li> <li>func (uc *UpdateConfigUseCase) Execute(input inputdto.ConfigDTO) (outputdto.ConfigDTO, error)</li> </ul>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#type-createconfigusecase","title":"type CreateConfigUseCase","text":"<p>CreateConfigUseCase is the use case for creating a new configuration.</p> <pre><code>type CreateConfigUseCase struct {\n    ConfigRepository entity.ConfigRepositoryInterface\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-newcreateconfigusecase","title":"func NewCreateConfigUseCase","text":"<pre><code>func NewCreateConfigUseCase(configRepository entity.ConfigRepositoryInterface) *CreateConfigUseCase\n</code></pre> <p>NewCreateConfigUseCase initializes a new instance of CreateConfigUseCase with the provided ConfigRepositoryInterface.</p> <p>Parameters:</p> <pre><code>configRepository: The repository interface for managing Config entities.\n</code></pre> <p>Returns:</p> <pre><code>A pointer to an instance of CreateConfigUseCase.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-createconfigusecase-execute","title":"func (*CreateConfigUseCase) Execute","text":"<pre><code>func (uc *CreateConfigUseCase) Execute(input inputdto.ConfigDTO) (outputdto.ConfigDTO, error)\n</code></pre> <p>Execute creates a new configuration entity based on the provided input DTO and saves it using the repository. It then converts the created entity to an output DTO and returns it.</p> <p>Parameters:</p> <pre><code>input: The input DTO containing the configuration data.\n</code></pre> <p>Returns:</p> <pre><code>An output DTO containing the created configuration data, and an error if any occurred during the process.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#type-deleteconfigusecase","title":"type DeleteConfigUseCase","text":"<p>DeleteConfigUseCase is the use case for deleting an existing configuration.</p> <pre><code>type DeleteConfigUseCase struct {\n    ConfigRepository entity.ConfigRepositoryInterface\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-newdeleteconfigusecase","title":"func NewDeleteConfigUseCase","text":"<pre><code>func NewDeleteConfigUseCase(configRepository entity.ConfigRepositoryInterface) *DeleteConfigUseCase\n</code></pre> <p>NewDeleteConfigUseCase initializes a new instance of DeleteConfigUseCase with the provided ConfigRepositoryInterface.</p> <p>Parameters:</p> <pre><code>configRepository: The repository interface for managing Config entities.\n</code></pre> <p>Returns:</p> <pre><code>A pointer to an instance of DeleteConfigUseCase.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-deleteconfigusecase-execute","title":"func (*DeleteConfigUseCase) Execute","text":"<pre><code>func (uc *DeleteConfigUseCase) Execute(id string) error\n</code></pre> <p>Execute deletes an existing configuration entity based on the provided ID.</p> <p>Parameters:</p> <pre><code>id: The ID of the configuration to be deleted.\n</code></pre> <p>Returns:</p> <pre><code>An error if any occurred during the process.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#type-listallbyprovideranddependsonconfigusecase","title":"type ListAllByProviderAndDependsOnConfigUseCase","text":"<p>ListAllByProviderAndDependsOnConfigUseCase is the use case for listing all configurations by their dependencies.</p> <pre><code>type ListAllByProviderAndDependsOnConfigUseCase struct {\n    ConfigRepository entity.ConfigRepositoryInterface\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-newlistallbyprovideranddependsonconfigusecase","title":"func NewListAllByProviderAndDependsOnConfigUseCase","text":"<pre><code>func NewListAllByProviderAndDependsOnConfigUseCase(configRepository entity.ConfigRepositoryInterface) *ListAllByProviderAndDependsOnConfigUseCase\n</code></pre> <p>NewListAllByProviderAndDependsOnConfigUseCase initializes a new instance of ListAllByProviderAndDependsOnConfigUseCase with the provided ConfigRepositoryInterface.</p> <p>Parameters:</p> <pre><code>configRepository: The repository interface for managing Config entities.\n</code></pre> <p>Returns:</p> <pre><code>A pointer to an instance of ListAllByProviderAndDependsOnConfigUseCase.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-listallbyprovideranddependsonconfigusecase-execute","title":"func (*ListAllByProviderAndDependsOnConfigUseCase) Execute","text":"<pre><code>func (uc *ListAllByProviderAndDependsOnConfigUseCase) Execute(provider, service, source string) ([]outputdto.ConfigDTO, error)\n</code></pre> <p>Execute retrieves all configurations by their dependencies from the repository.</p> <p>Parameters:</p> <pre><code>provider: The provider name to filter configurations by.\nservice: The service name to filter configurations by.\nsource: The source name to filter configurations by.\n</code></pre> <p>Returns:</p> <pre><code>A slice of output DTOs containing the configuration data, and an error if any occurred during the process.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#type-listallbyserviceandproviderandactiveconfigusecase","title":"type ListAllByServiceAndProviderAndActiveConfigUseCase","text":"<p>ListAllByServiceAndProviderAndActiveConfigUseCase is the use case for listing all configurations by service, provider, and active status.</p> <pre><code>type ListAllByServiceAndProviderAndActiveConfigUseCase struct {\n    ConfigRepository entity.ConfigRepositoryInterface\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-newlistallbyserviceandproviderandactiveconfigusecase","title":"func NewListAllByServiceAndProviderAndActiveConfigUseCase","text":"<pre><code>func NewListAllByServiceAndProviderAndActiveConfigUseCase(configRepository entity.ConfigRepositoryInterface) *ListAllByServiceAndProviderAndActiveConfigUseCase\n</code></pre> <p>NewListAllByServiceAndProviderAndActiveConfigUseCase initializes a new instance of ListAllByServiceAndProviderAndActiveConfigUseCase with the provided ConfigRepositoryInterface.</p> <p>Parameters:</p> <pre><code>configRepository: The repository interface for managing Config entities.\n</code></pre> <p>Returns:</p> <pre><code>A pointer to an instance of ListAllByServiceAndProviderAndActiveConfigUseCase.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-listallbyserviceandproviderandactiveconfigusecase-execute","title":"func (*ListAllByServiceAndProviderAndActiveConfigUseCase) Execute","text":"<pre><code>func (uc *ListAllByServiceAndProviderAndActiveConfigUseCase) Execute(service, provider string, active bool) ([]outputdto.ConfigDTO, error)\n</code></pre> <p>Execute retrieves all configurations by service, provider, and active status from the repository.</p> <p>Parameters:</p> <pre><code>service: The service name to filter configurations by.\nprovider: The provider name to filter configurations by.\nactive: The active status to filter configurations by.\n</code></pre> <p>Returns:</p> <pre><code>A slice of output DTOs containing the configuration data, and an error if any occurred during the process.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#type-listallbyserviceandproviderconfigusecase","title":"type ListAllByServiceAndProviderConfigUseCase","text":"<p>ListAllByServiceAndProviderConfigUseCase is the use case for listing all configurations by service.</p> <pre><code>type ListAllByServiceAndProviderConfigUseCase struct {\n    ConfigRepository entity.ConfigRepositoryInterface\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-newlistallbyserviceandproviderconfigusecase","title":"func NewListAllByServiceAndProviderConfigUseCase","text":"<pre><code>func NewListAllByServiceAndProviderConfigUseCase(configRepository entity.ConfigRepositoryInterface) *ListAllByServiceAndProviderConfigUseCase\n</code></pre> <p>NewListAllByServiceConfigUseCase initializes a new instance of ListAllByServiceAndProviderConfigUseCase with the provided ConfigRepositoryInterface.</p> <p>Parameters:</p> <pre><code>configRepository: The repository interface for managing Config entities.\n</code></pre> <p>Returns:</p> <pre><code>A pointer to an instance of ListAllByServiceAndProviderConfigUseCase.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-listallbyserviceandproviderconfigusecase-execute","title":"func (*ListAllByServiceAndProviderConfigUseCase) Execute","text":"<pre><code>func (uc *ListAllByServiceAndProviderConfigUseCase) Execute(provider, service string) ([]outputdto.ConfigDTO, error)\n</code></pre> <p>Execute retrieves all configurations by service from the repository.</p> <p>Parameters:</p> <pre><code>provider: The provider name to filter configurations by.\nservice: The service name to filter configurations by.\n</code></pre> <p>Returns:</p> <pre><code>A slice of output DTOs containing the configuration data, and an error if any occurred during the process.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#type-listallbyserviceandsourceandproviderconfigusecase","title":"type ListAllByServiceAndSourceAndProviderConfigUseCase","text":"<p>ListAllByServiceAndSourceAndProviderConfigUseCase is the use case for listing all configurations by service, source, and provider.</p> <pre><code>type ListAllByServiceAndSourceAndProviderConfigUseCase struct {\n    ConfigRepository entity.ConfigRepositoryInterface\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-newlistallbyserviceandsourceandproviderconfigusecase","title":"func NewListAllByServiceAndSourceAndProviderConfigUseCase","text":"<pre><code>func NewListAllByServiceAndSourceAndProviderConfigUseCase(configRepository entity.ConfigRepositoryInterface) *ListAllByServiceAndSourceAndProviderConfigUseCase\n</code></pre> <p>NewListAllByServiceAndSourceAndProviderConfigUseCase initializes a new instance of ListAllByServiceAndSourceAndProviderConfigUseCase with the provided ConfigRepositoryInterface.</p> <p>Parameters:</p> <pre><code>configRepository: The repository interface for managing Config entities.\n</code></pre> <p>Returns:</p> <pre><code>A pointer to an instance of ListAllByServiceAndSourceAndProviderConfigUseCase.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-listallbyserviceandsourceandproviderconfigusecase-execute","title":"func (*ListAllByServiceAndSourceAndProviderConfigUseCase) Execute","text":"<pre><code>func (uc *ListAllByServiceAndSourceAndProviderConfigUseCase) Execute(service, source, provider string) ([]outputdto.ConfigDTO, error)\n</code></pre> <p>Execute retrieves all configurations by service, source, and provider from the repository.</p> <p>Parameters:</p> <pre><code>service: The service name to filter configurations by.\nsource: The source name to filter configurations by.\nprovider: The provider name to filter configurations by.\n</code></pre> <p>Returns:</p> <pre><code>A slice of output DTOs containing the configuration data, and an error if any occurred during the process.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#type-listallbysourceandproviderconfigusecase","title":"type ListAllBySourceAndProviderConfigUseCase","text":"<p>ListAllBySourceAndProviderConfigUseCase is the use case for listing all configurations by source.</p> <pre><code>type ListAllBySourceAndProviderConfigUseCase struct {\n    ConfigRepository entity.ConfigRepositoryInterface\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-newlistallbysourceandproviderconfigusecase","title":"func NewListAllBySourceAndProviderConfigUseCase","text":"<pre><code>func NewListAllBySourceAndProviderConfigUseCase(configRepository entity.ConfigRepositoryInterface) *ListAllBySourceAndProviderConfigUseCase\n</code></pre> <p>NewListAllBySourceAndProviderConfigUseCase initializes a new instance of ListAllBySourceAndProviderConfigUseCase with the provided ConfigRepositoryInterface.</p> <p>Parameters:</p> <pre><code>configRepository: The repository interface for managing Config entities.\n</code></pre> <p>Returns:</p> <pre><code>A pointer to an instance of ListAllBySourceAndProviderConfigUseCase.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-listallbysourceandproviderconfigusecase-execute","title":"func (*ListAllBySourceAndProviderConfigUseCase) Execute","text":"<pre><code>func (uc *ListAllBySourceAndProviderConfigUseCase) Execute(provider, source string) ([]outputdto.ConfigDTO, error)\n</code></pre> <p>Execute retrieves all configurations by source from the repository.</p> <p>Parameters:</p> <pre><code>provider: The provider name to filter configurations by.\nsource: The source name to filter configurations by.\n</code></pre> <p>Returns:</p> <pre><code>A slice of output DTOs containing the configuration data, and an error if any occurred during the process.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#type-listallconfigusecase","title":"type ListAllConfigUseCase","text":"<p>ListAllConfigUseCase is the use case for listing all configurations.</p> <pre><code>type ListAllConfigUseCase struct {\n    ConfigRepository entity.ConfigRepositoryInterface\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-newlistallconfigusecase","title":"func NewListAllConfigUseCase","text":"<pre><code>func NewListAllConfigUseCase(configRepository entity.ConfigRepositoryInterface) *ListAllConfigUseCase\n</code></pre> <p>NewListAllConfigUseCase initializes a new instance of ListAllConfigUseCase with the provided ConfigRepositoryInterface.</p> <p>Parameters:</p> <pre><code>configRepository: The repository interface for managing Config entities.\n</code></pre> <p>Returns:</p> <pre><code>A pointer to an instance of ListAllConfigUseCase.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-listallconfigusecase-execute","title":"func (*ListAllConfigUseCase) Execute","text":"<pre><code>func (uc *ListAllConfigUseCase) Execute() ([]outputdto.ConfigDTO, error)\n</code></pre> <p>Execute retrieves all configurations from the repository and converts them to output DTOs.</p> <p>Returns:</p> <pre><code>A slice of output DTOs containing the configuration data, and an error if any occurred during the process.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#type-listonebyidconfigusecase","title":"type ListOneByIDConfigUseCase","text":"<p>ListOneByIDConfigUseCase is the use case for listing a single configuration by its ID.</p> <pre><code>type ListOneByIDConfigUseCase struct {\n    ConfigRepository entity.ConfigRepositoryInterface\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-newlistonebyidconfigusecase","title":"func NewListOneByIDConfigUseCase","text":"<pre><code>func NewListOneByIDConfigUseCase(configRepository entity.ConfigRepositoryInterface) *ListOneByIDConfigUseCase\n</code></pre> <p>NewListOneByIDConfigUseCase initializes a new instance of ListOneByIDConfigUseCase with the provided ConfigRepositoryInterface.</p> <p>Parameters:</p> <pre><code>configRepository: The repository interface for managing Config entities.\n</code></pre> <p>Returns:</p> <pre><code>A pointer to an instance of ListOneByIDConfigUseCase.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-listonebyidconfigusecase-execute","title":"func (*ListOneByIDConfigUseCase) Execute","text":"<pre><code>func (uc *ListOneByIDConfigUseCase) Execute(id string) (outputdto.ConfigDTO, error)\n</code></pre> <p>Execute retrieves a configuration by its ID from the repository and converts it to an output DTO.</p> <p>Parameters:</p> <pre><code>id: The ID of the configuration to retrieve.\n</code></pre> <p>Returns:</p> <pre><code>An output DTO containing the configuration data, and an error if any occurred during the process.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#type-updateconfigusecase","title":"type UpdateConfigUseCase","text":"<p>UpdateConfigUseCase is the use case for updating an existing configuration.</p> <pre><code>type UpdateConfigUseCase struct {\n    ConfigRepository entity.ConfigRepositoryInterface\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-newupdateconfigusecase","title":"func NewUpdateConfigUseCase","text":"<pre><code>func NewUpdateConfigUseCase(configRepository entity.ConfigRepositoryInterface) *UpdateConfigUseCase\n</code></pre> <p>NewUpdateConfigUseCase initializes a new instance of UpdateConfigUseCase with the provided ConfigRepositoryInterface.</p> <p>Parameters:</p> <pre><code>configRepository: The repository interface for managing Config entities.\n</code></pre> <p>Returns:</p> <pre><code>A pointer to an instance of UpdateConfigUseCase.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/ddd/usecases/config-vault/docs/godoc/#func-updateconfigusecase-execute","title":"func (*UpdateConfigUseCase) Execute","text":"<pre><code>func (uc *UpdateConfigUseCase) Execute(input inputdto.ConfigDTO) (outputdto.ConfigDTO, error)\n</code></pre> <p>Execute updates an existing configuration entity based on the provided input DTO and saves it using the repository. It then converts the updated entity to an output DTO and returns it.</p> <p>Parameters:</p> <pre><code>input: The input DTO containing the configuration data.\n</code></pre> <p>Returns:</p> <pre><code>An output DTO containing the updated configuration data, and an error if any occurred during the process.\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/server/http/chi-webserver/","title":"webserver","text":"<p><code>webserver</code> is a Go library that provides a simple and flexible HTTP server using the <code>chi</code> router. This library allows you to create and configure an HTTP server with default middlewares, register routes, and manage route groups efficiently.</p>"},{"location":"reference/libs/golang/server/http/chi-webserver/#features","title":"Features","text":"<ul> <li>Create and configure an HTTP server with default middlewares.</li> <li>Register individual routes with different HTTP methods.</li> <li>Group routes under common prefixes.</li> <li>Easy-to-use interface for starting the server.</li> </ul>"},{"location":"reference/libs/golang/server/http/chi-webserver/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/server/http/chi-webserver/#creating-and-configuring-the-web-server","title":"Creating and Configuring the Web Server","text":"<p>The <code>NewWebServer</code> function creates a new <code>Server</code> instance with the specified address.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"libs/golang/server/http/chi-webserver/server\"\n)\n\nfunc helloHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintln(w, \"Hello, world!\")\n}\n\nfunc main() {\n    server := webserver.NewWebServer(\":8080\")\n    server.ConfigureDefaults()\n    server.RegisterRoute(\"GET\", \"/hello\", helloHandler)\n\n    if err := server.Start(); err != nil {\n        fmt.Println(\"Error starting server:\", err)\n    }\n}\n</code></pre>"},{"location":"reference/libs/golang/server/http/chi-webserver/#adding-default-middlewares","title":"Adding Default Middlewares","text":"<p>The <code>ConfigureDefaults</code> method sets up default middlewares for the server, including request ID, real IP, logger, recoverer, and a timeout of 60 seconds.</p> <pre><code>func main() {\n    server := webserver.NewWebServer(\":8080\")\n    server.ConfigureDefaults()\n    // Other configuration and route registration\n}\n</code></pre>"},{"location":"reference/libs/golang/server/http/chi-webserver/#registering-routes","title":"Registering Routes","text":"<p>The <code>RegisterRoute</code> method adds a new route with the specified HTTP method, URL pattern, and handler function.</p> <pre><code>func main() {\n    server := webserver.NewWebServer(\":8080\")\n    server.ConfigureDefaults()\n\n    server.RegisterRoute(\"GET\", \"/hello\", helloHandler)\n    server.RegisterRoute(\"POST\", \"/submit\", submitHandler)\n\n    if err := server.Start(); err != nil {\n        fmt.Println(\"Error starting server:\", err)\n    }\n}\n</code></pre>"},{"location":"reference/libs/golang/server/http/chi-webserver/#grouping-routes","title":"Grouping Routes","text":"<p>The <code>RegisterRouteGroup</code> method allows you to group routes under a common prefix.</p> <pre><code>func main() {\n    server := webserver.NewWebServer(\":8080\")\n    server.ConfigureDefaults()\n\n    server.RegisterRouteGroup(\"/api\", func(r chi.Router) {\n        r.Get(\"/hello\", helloHandler)\n        r.Post(\"/submit\", submitHandler)\n    })\n\n    if err := server.Start(); err != nil {\n        fmt.Println(\"Error starting server:\", err)\n    }\n}\n</code></pre>"},{"location":"reference/libs/golang/server/http/chi-webserver/#starting-the-server","title":"Starting the Server","text":"<p>The <code>Start</code> method runs the web server on the specified address.</p> <pre><code>func main() {\n    server := webserver.NewWebServer(\":8080\")\n    server.ConfigureDefaults()\n\n    server.RegisterRoute(\"GET\", \"/hello\", helloHandler)\n\n    if err := server.Start(); err != nil {\n        fmt.Println(\"Error starting server:\", err)\n    }\n}\n</code></pre>"},{"location":"reference/libs/golang/server/http/chi-webserver/#api","title":"API","text":""},{"location":"reference/libs/golang/server/http/chi-webserver/#server","title":"Server","text":""},{"location":"reference/libs/golang/server/http/chi-webserver/#newwebserveraddr-string-server","title":"<code>NewWebServer(addr string) *Server</code>","text":"<p>Creates and returns a new <code>Server</code> instance with the specified address.</p>"},{"location":"reference/libs/golang/server/http/chi-webserver/#configuredefaults","title":"<code>ConfigureDefaults()</code>","text":"<p>Sets up default middlewares for the server, including request ID, real IP, logger, recoverer, and a timeout of 60 seconds.</p>"},{"location":"reference/libs/golang/server/http/chi-webserver/#registermiddlewaresmiddlewares-funchttphandler-httphandler","title":"<code>RegisterMiddlewares(middlewares ...func(http.Handler) http.Handler)</code>","text":"<p>Adds multiple middlewares to the server.</p>"},{"location":"reference/libs/golang/server/http/chi-webserver/#registerroutemethod-pattern-string-handler-httphandlerfunc-group-string","title":"<code>RegisterRoute(method, pattern string, handler http.HandlerFunc, group ...string)</code>","text":"<p>Adds a new route with an HTTP method, pattern, and handler function. Optionally, a group name can be specified.</p>"},{"location":"reference/libs/golang/server/http/chi-webserver/#registerroutegroupprefix-string-routes-funcr-chirouter","title":"<code>RegisterRouteGroup(prefix string, routes func(r chi.Router))</code>","text":"<p>Registers a group of routes under a common prefix.</p>"},{"location":"reference/libs/golang/server/http/chi-webserver/#start-error","title":"<code>Start() error</code>","text":"<p>Runs the web server on the specified address.</p>"},{"location":"reference/libs/golang/server/http/chi-webserver/#example","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"libs/golang/server/http/chi-webserver/server\"\n)\n\nfunc helloHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintln(w, \"Hello, world!\")\n}\n\nfunc main() {\n    server := webserver.NewWebServer(\":8080\")\n    server.ConfigureDefaults()\n\n    server.RegisterRoute(\"GET\", \"/hello\", helloHandler)\n\n    if err := server.Start(); err != nil {\n        fmt.Println(\"Error starting server:\", err)\n    }\n}\n</code></pre>"},{"location":"reference/libs/golang/server/http/chi-webserver/#testing","title":"Testing","text":"<p>To run the tests for the <code>webserver</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-server-http-chi-webserver\n</code></pre>"},{"location":"reference/libs/golang/server/http/chi-webserver/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/server/http/chi-webserver/docs/godoc/#webserver","title":"webserver","text":"<pre><code>import \"libs/golang/server/http/chi-webserver/server\"\n</code></pre>"},{"location":"reference/libs/golang/server/http/chi-webserver/docs/godoc/#index","title":"Index","text":"<ul> <li>type Server</li> <li>func NewWebServer(addr string) *Server</li> <li>func (s *Server) ConfigureDefaults()</li> <li>func (s *Server) RegisterMiddlewares(middlewares ...func(http.Handler) http.Handler)</li> <li>func (s *Server) RegisterRoute(method, pattern string, handler http.HandlerFunc, group ...string)</li> <li>func (s *Server) RegisterRouteGroup(prefix string, routes func(r chi.Router))</li> <li>func (s *Server) Start() error</li> </ul>"},{"location":"reference/libs/golang/server/http/chi-webserver/docs/godoc/#type-server","title":"type Server","text":"<p>Server represents an HTTP server with a router and address.</p> <pre><code>type Server struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/server/http/chi-webserver/docs/godoc/#func-newwebserver","title":"func NewWebServer","text":"<pre><code>func NewWebServer(addr string) *Server\n</code></pre> <p>NewWebServer creates and returns a new Server instance with the specified address.</p> <p>Parameters:</p> <pre><code>addr: The address to run the server on.\n</code></pre> <p>Returns:</p> <pre><code>A new Server instance.\n</code></pre> <p></p>"},{"location":"reference/libs/golang/server/http/chi-webserver/docs/godoc/#func-server-configuredefaults","title":"func (*Server) ConfigureDefaults","text":"<pre><code>func (s *Server) ConfigureDefaults()\n</code></pre> <p>ConfigureDefaults sets up the default middleware for the server, including request ID, real IP, logger, recoverer, and a timeout of 60 seconds.</p> <p></p>"},{"location":"reference/libs/golang/server/http/chi-webserver/docs/godoc/#func-server-registermiddlewares","title":"func (*Server) RegisterMiddlewares","text":"<pre><code>func (s *Server) RegisterMiddlewares(middlewares ...func(http.Handler) http.Handler)\n</code></pre> <p>RegisterMiddlewares adds multiple middlewares to the server.</p> <p>Parameters:</p> <pre><code>middlewares: A list of middleware functions to add to the server.\n</code></pre> <p>Returns:</p> <pre><code>None.\n</code></pre> <p>Example:</p> <pre><code>server.RegisterMiddlewares(middleware1, middleware2, middleware3)\n</code></pre> <p>This will add middleware1, middleware2, and middleware3 to the server.</p> <p></p>"},{"location":"reference/libs/golang/server/http/chi-webserver/docs/godoc/#func-server-registerroute","title":"func (*Server) RegisterRoute","text":"<pre><code>func (s *Server) RegisterRoute(method, pattern string, handler http.HandlerFunc, group ...string)\n</code></pre> <p>RegisterRoute adds a new route with an HTTP method, pattern, and handler function. If a group is specified, the route is added to that group.</p> <p>Parameters:</p> <pre><code>method: The HTTP method for the route.\npattern: The URL pattern for the route.\nhandler: The handler function for the route.\ngroup: An optional group name to add the route to.\n</code></pre> <p>Returns:</p> <pre><code>None.\n</code></pre> <p>Example:</p> <pre><code>server.RegisterRoute(\"GET\", \"/hello\", helloHandler)\n</code></pre> <p>This will add a new route to the server that listens for GET requests on the /hello URL pattern and calls the helloHandler function.</p> <p></p>"},{"location":"reference/libs/golang/server/http/chi-webserver/docs/godoc/#func-server-registerroutegroup","title":"func (*Server) RegisterRouteGroup","text":"<pre><code>func (s *Server) RegisterRouteGroup(prefix string, routes func(r chi.Router))\n</code></pre> <p>RegisterRouteGroup registers a group of routes under a common prefix.</p> <p>Parameters:</p> <pre><code>prefix: The common prefix for the group of routes.\nroutes: A function that defines the routes for the group.\n</code></pre> <p>Returns:</p> <pre><code>None.\n</code></pre> <p>Example:</p> <pre><code>server.RegisterRouteGroup(\"/api\", func(r chi.Router) {\n    r.Get(\"/hello\", helloHandler)\n    r.Post(\"/world\", worldHandler)\n})\n</code></pre> <p>This will add a group of routes under the /api prefix with two routes: /hello and /world.</p> <p></p>"},{"location":"reference/libs/golang/server/http/chi-webserver/docs/godoc/#func-server-start","title":"func (*Server) Start","text":"<pre><code>func (s *Server) Start() error\n</code></pre> <p>Start runs the web server on the specified address.</p> <p>Parameters:</p> <pre><code>None.\n</code></pre> <p>Returns:</p> <pre><code>An error if the server fails to start.\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/service-discovery/","title":"service-discovery","text":"<p><code>service-discovery</code> is a Go library that facilitates the registration and retrieval of various service resources. It follows the singleton pattern and provides methods for registering and accessing resources like MongoDB, Minio, and RabbitMQ.</p>"},{"location":"reference/libs/golang/service-discovery/#features","title":"Features","text":"<ul> <li>Register and initialize resources such as MongoDB, Minio, and RabbitMQ.</li> <li>Retrieve registered resources by key.</li> <li>Singleton instance ensuring a single point of resource management.</li> </ul>"},{"location":"reference/libs/golang/service-discovery/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/service-discovery/#initializing-service-discovery","title":"Initializing Service Discovery","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/service-discovery/sd\"\n)\n\nfunc main() {\n    serviceDiscovery := servicediscovery.NewServiceDiscovery()\n    fmt.Println(\"Service Discovery initialized\")\n}\n</code></pre>"},{"location":"reference/libs/golang/service-discovery/#registering-a-resource","title":"Registering a Resource","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/service-discovery/sd\"\n    resourceImpl \"libs/golang/wrappers/core/resource-contract\"\n)\n\ntype MockResource struct{}\n\nfunc (m *MockResource) Init() error {\n    // Initialize the resource\n    return nil\n}\n\nfunc (m *MockResource) GetClient() interface{} {\n    // Return the resource client\n    return nil\n}\n\nfunc main() {\n    serviceDiscovery := servicediscovery.NewServiceDiscovery()\n\n    mockResource := &amp;MockResource{}\n    serviceDiscovery.RegisterResource(\"mock\", mockResource)\n\n    fmt.Println(\"Mock resource registered\")\n}\n</code></pre>"},{"location":"reference/libs/golang/service-discovery/#retrieving-a-registered-resource","title":"Retrieving a Registered Resource","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/service-discovery/sd\"\n)\n\nfunc main() {\n    serviceDiscovery := servicediscovery.NewServiceDiscovery()\n\n    resource, err := serviceDiscovery.GetResource(\"mock\")\n    if err != nil {\n        fmt.Println(\"Error retrieving resource:\", err)\n        return\n    }\n\n    fmt.Println(\"Resource retrieved:\", resource)\n}\n</code></pre>"},{"location":"reference/libs/golang/service-discovery/#testing","title":"Testing","text":"<p>To run the tests for the <code>servicediscovery</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-service-discovery\n</code></pre>"},{"location":"reference/libs/golang/service-discovery/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/service-discovery/docs/godoc/#servicediscovery","title":"servicediscovery","text":"<pre><code>import \"libs/golang/service-discovery/sd\"\n</code></pre>"},{"location":"reference/libs/golang/service-discovery/docs/godoc/#index","title":"Index","text":"<ul> <li>func SetResourceInitializer(initializer func(resourceImpl.Resource))</li> <li>type ServiceDiscovery</li> <li>func NewServiceDiscovery() *ServiceDiscovery</li> <li>func (s *ServiceDiscovery) GetResource(key string) (resourceImpl.Resource, error)</li> <li>func (s *ServiceDiscovery) InitResourceWrapper(wrapper resourceImpl.Resource)</li> <li>func (s *ServiceDiscovery) RegisterResource(key string, resource resourceImpl.Resource)</li> </ul>"},{"location":"reference/libs/golang/service-discovery/docs/godoc/#func-setresourceinitializer","title":"func SetResourceInitializer","text":"<pre><code>func SetResourceInitializer(initializer func(resourceImpl.Resource))\n</code></pre> <p>SetResourceInitializer sets the resource initializer function, typically used for testing.</p> <p></p>"},{"location":"reference/libs/golang/service-discovery/docs/godoc/#type-servicediscovery","title":"type ServiceDiscovery","text":"<p>ServiceDiscovery holds the service discovery logic, managing resource mappings and services.</p> <pre><code>type ServiceDiscovery struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/service-discovery/docs/godoc/#func-newservicediscovery","title":"func NewServiceDiscovery","text":"<pre><code>func NewServiceDiscovery() *ServiceDiscovery\n</code></pre> <p>NewServiceDiscovery creates and returns a singleton instance of ServiceDiscovery.</p> <p></p>"},{"location":"reference/libs/golang/service-discovery/docs/godoc/#func-servicediscovery-getresource","title":"func (*ServiceDiscovery) GetResource","text":"<pre><code>func (s *ServiceDiscovery) GetResource(key string) (resourceImpl.Resource, error)\n</code></pre> <p>GetResource retrieves a resource by key from the resource mapping.</p> <p></p>"},{"location":"reference/libs/golang/service-discovery/docs/godoc/#func-servicediscovery-initresourcewrapper","title":"func (*ServiceDiscovery) InitResourceWrapper","text":"<pre><code>func (s *ServiceDiscovery) InitResourceWrapper(wrapper resourceImpl.Resource)\n</code></pre> <p>InitResourceWrapper initializes the given resource wrapper using the configured initializer.</p> <p></p>"},{"location":"reference/libs/golang/service-discovery/docs/godoc/#func-servicediscovery-registerresource","title":"func (*ServiceDiscovery) RegisterResource","text":"<pre><code>func (s *ServiceDiscovery) RegisterResource(key string, resource resourceImpl.Resource)\n</code></pre> <p>RegisterResource registers a resource with the given key.</p> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/shared/id/go-md5/","title":"go-md5","text":"<p><code>go-md5</code> is a Go library that provides utilities for generating MD5-based IDs from various data types. This library leverages the <code>type-tools</code> library to convert different types of data into a string representation before generating the MD5 hash.</p>"},{"location":"reference/libs/golang/shared/id/go-md5/#features","title":"Features","text":"<ul> <li>Generate MD5-based IDs from various data types including:</li> <li><code>string</code></li> <li><code>float64</code></li> <li><code>int</code> and other integer types</li> <li><code>bool</code></li> <li><code>map[string]interface{}</code></li> <li><code>map[string]string</code></li> </ul>"},{"location":"reference/libs/golang/shared/id/go-md5/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/shared/id/go-md5/#generating-an-id-from-a-string","title":"Generating an ID from a String","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/shared/id/go-md5\"\n)\n\nfunc main() {\n    id := md5id.NewID(\"test\")\n    fmt.Println(id) // Output: 098f6bcd4621d373cade4e832627b4f6\n}\n</code></pre>"},{"location":"reference/libs/golang/shared/id/go-md5/#generating-an-id-from-a-float64","title":"Generating an ID from a Float64","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/shared/id/go-md5\"\n)\n\nfunc main() {\n    id := md5id.NewID(123.456)\n    fmt.Println(id) // Output: f6e809317508ea1fdcb5e6d878e166ef\n}\n</code></pre>"},{"location":"reference/libs/golang/shared/id/go-md5/#generating-an-id-from-a-map","title":"Generating an ID from a Map","text":""},{"location":"reference/libs/golang/shared/id/go-md5/#map-of-string-to-interface","title":"Map of String to Interface","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/shared/id/go-md5\"\n)\n\nfunc main() {\n    data := map[string]interface{}{\n        \"foo\": \"bar\",\n        \"baz\": 123,\n    }\n    id := md5id.NewID(data)\n    fmt.Println(id) // Output: 7cc94a32929de9da271e6f19ef1392d7\n}\n</code></pre>"},{"location":"reference/libs/golang/shared/id/go-md5/#map-of-string-to-string","title":"Map of String to String","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/shared/id/go-md5\"\n)\n\nfunc main() {\n    data := map[string]string{\n        \"foo\": \"bar\",\n        \"baz\": \"qux\",\n    }\n    id := md5id.NewID(data)\n    fmt.Println(id) // Output: 491ebd8bf73d6a9b2fabf44575e98fbe\n}\n</code></pre>"},{"location":"reference/libs/golang/shared/id/go-md5/#generating-an-id-from-an-integer","title":"Generating an ID from an Integer","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/shared/id/go-md5\"\n)\n\nfunc main() {\n    id := md5id.NewID(123)\n    fmt.Println(id) // Output: 202cb962ac59075b964b07152d234b70\n}\n</code></pre>"},{"location":"reference/libs/golang/shared/id/go-md5/#generating-an-id-from-a-boolean","title":"Generating an ID from a Boolean","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/shared/id/go-md5\"\n)\n\nfunc main() {\n    id := md5id.NewID(true)\n    fmt.Println(id) // Output: b326b5062b2f0e69046810717534cb09\n\n    id = md5id.NewID(false)\n    fmt.Println(id) // Output: 68934a3e9455fa72420237eb05902327\n}\n</code></pre>"},{"location":"reference/libs/golang/shared/id/go-md5/#testing","title":"Testing","text":"<p>To run the tests for the <code>md5id</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-shared-id-go-md5\n</code></pre>"},{"location":"reference/libs/golang/shared/id/go-md5/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/shared/id/go-md5/docs/godoc/#md5id","title":"md5id","text":"<pre><code>import \"libs/golang/shared/id/go-md5\"\n</code></pre>"},{"location":"reference/libs/golang/shared/id/go-md5/docs/godoc/#index","title":"Index","text":"<ul> <li>type ID</li> <li>func NewID(data interface{}) ID</li> </ul>"},{"location":"reference/libs/golang/shared/id/go-md5/docs/godoc/#type-id","title":"type ID","text":"<p>ID type definition</p> <pre><code>type ID string\n</code></pre> <p></p>"},{"location":"reference/libs/golang/shared/id/go-md5/docs/godoc/#func-newid","title":"func NewID","text":"<pre><code>func NewID(data interface{}) ID\n</code></pre> <p>NewID generates an ID from various types of data</p> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/shared/id/go-uuid/","title":"go-uuid","text":"<p><code>go-uuid</code> is a Go library that provides utilities for generating UUIDs from various data types. It includes functions for calculating SHA-256 hashes and generating UUIDs based on those hashes.</p>"},{"location":"reference/libs/golang/shared/id/go-uuid/#features","title":"Features","text":"<ul> <li>Generate UUIDs from various data types including:</li> <li><code>map[string]interface{}</code></li> <li>Other data types using serialization to <code>[]byte</code></li> <li>Calculate SHA-256 hashes of data</li> </ul>"},{"location":"reference/libs/golang/shared/id/go-uuid/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/shared/id/go-uuid/#generating-a-uuid-from-a-map","title":"Generating a UUID from a Map","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/shared/id/go-uuid\"\n)\n\nfunc main() {\n    data := map[string]interface{}{\n        \"key1\": \"value1\",\n        \"key2\": 123,\n    }\n    id, err := gouuid.GenerateUUIDFromMap(data)\n    if err != nil {\n        fmt.Println(\"Error generating UUID:\", err)\n        return\n    }\n    fmt.Println(\"Generated UUID:\", id)\n}\n</code></pre>"},{"location":"reference/libs/golang/shared/id/go-uuid/#generating-a-uuid-from-other-data-types","title":"Generating a UUID from Other Data Types","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/shared/id/go-uuid\"\n)\n\nfunc main() {\n    data := \"test\"\n    id, err := gouuid.GenerateUUID([]byte(data))\n    if err != nil {\n        fmt.Println(\"Error generating UUID:\", err)\n        return\n    }\n    fmt.Println(\"Generated UUID:\", id)\n}\n</code></pre>"},{"location":"reference/libs/golang/shared/id/go-uuid/#testing","title":"Testing","text":"<p>To run the tests for the <code>gouuid</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-shared-id-go-uuid\n</code></pre>"},{"location":"reference/libs/golang/shared/id/go-uuid/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/shared/id/go-uuid/docs/godoc/#gouuid","title":"gouuid","text":"<pre><code>import \"libs/golang/shared/id/go-uuid\"\n</code></pre>"},{"location":"reference/libs/golang/shared/id/go-uuid/docs/godoc/#index","title":"Index","text":"<ul> <li>type ID</li> <li>func GenerateUUIDFromMap(data map[string]interface{}) (ID, error)</li> </ul>"},{"location":"reference/libs/golang/shared/id/go-uuid/docs/godoc/#type-id","title":"type ID","text":"<p>ID represents a unique identifier.</p> <pre><code>type ID = string\n</code></pre> <p></p>"},{"location":"reference/libs/golang/shared/id/go-uuid/docs/godoc/#func-generateuuidfrommap","title":"func GenerateUUIDFromMap","text":"<pre><code>func GenerateUUIDFromMap(data map[string]interface{}) (ID, error)\n</code></pre> <p>GenerateUUIDFromMap generates a UUID from a map. It serializes the map into JSON, calculates the hash of the JSON data, and generates a UUID from the hash.</p> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/shared/type-tools/","title":"type-tools","text":"<p><code>type-tools</code> is a Go library that provides utilities for converting various data types (Go's built-in types). This library is designed to be simple and efficient, making it easy to handle different types of data in a consistent manner.</p>"},{"location":"reference/libs/golang/shared/type-tools/#features","title":"Features","text":"<ul> <li>Convert <code>map[string]interface{}</code> to a sorted string representation.</li> <li>Convert <code>map[string]string</code> to a sorted string representation.</li> <li>Convert <code>float64</code> to a string representation.</li> <li>Convert <code>interface{}</code> to specific Go built-in types.</li> <li>Generic function to convert any type to a string.</li> <li>Parse date strings with a given format.</li> </ul>"},{"location":"reference/libs/golang/shared/type-tools/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/shared/type-tools/#convert-mapstringinterface-to-string","title":"Convert <code>map[string]interface{}</code> to String","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/shared/type-tools\"\n)\n\nfunc main() {\n    data := map[string]interface{}{\n        \"foo\": \"bar\",\n        \"baz\": 123,\n    }\n    str := typetools.MapInterfaceToString(data)\n    fmt.Println(str) // Output: baz:123;foo:bar;\n}\n</code></pre>"},{"location":"reference/libs/golang/shared/type-tools/#convert-mapstringstring-to-string","title":"Convert <code>map[string]string</code> to String","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/shared/type-tools\"\n)\n\nfunc main() {\n    data := map[string]string{\n        \"foo\": \"bar\",\n        \"baz\": \"qux\",\n    }\n    str := typetools.MapStringToString(data)\n    fmt.Println(str) // Output: baz:qux;foo:bar;\n}\n</code></pre>"},{"location":"reference/libs/golang/shared/type-tools/#convert-various-types-to-string","title":"Convert Various Types to String","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/shared/type-tools\"\n)\n\nfunc main() {\n    str := typetools.ToString(\"test\")\n    fmt.Println(str) // Output: test\n\n    str = typetools.ToString(123.456)\n    fmt.Println(str) // Output: 123.456000\n\n    data := map[string]interface{}{\n        \"foo\": \"bar\",\n        \"baz\": 123,\n    }\n    str = typetools.ToString(data)\n    fmt.Println(str) // Output: baz:123;foo:bar;\n\n    dataString := map[string]string{\n        \"foo\": \"bar\",\n        \"baz\": \"qux\",\n    }\n    str = typetools.ToString(dataString)\n    fmt.Println(str) // Output: baz:qux;foo:bar;\n}\n</code></pre>"},{"location":"reference/libs/golang/shared/type-tools/#convert-interface-to-specific-types","title":"Convert Interface to Specific Types","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"libs/golang/shared/type-tools\"\n)\n\nfunc main() {\n    var intf interface{} = \"123\"\n    str, err := typetools.ToString(intf)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    } else {\n        fmt.Println(str) // Output: 123\n    }\n\n    var num interface{} = 123.456\n    floatStr, err := typetools.ToFloat64(num)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    } else {\n        fmt.Println(floatStr) // Output: 123.456\n    }\n}\n</code></pre>"},{"location":"reference/libs/golang/shared/type-tools/#parse-date-with-format","title":"Parse Date with Format","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n    \"github.com/yourusername/yourrepository/type-tools\"\n)\n\nfunc main() {\n    dateStr := \"2023-01-01\"\n    format := \"2006-01-02\"\n\n    date, err := typetools.ParseDateWithFormat(dateStr, format)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    fmt.Println(\"Parsed date:\", date.Format(time.RFC3339))\n}\n</code></pre>"},{"location":"reference/libs/golang/shared/type-tools/#testing","title":"Testing","text":"<p>To run the tests for <code>typetools</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-shared-type-tools\n</code></pre>"},{"location":"reference/libs/golang/shared/type-tools/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/shared/type-tools/docs/godoc/#typetools","title":"typetools","text":"<pre><code>import \"libs/golang/shared/type-tools\"\n</code></pre>"},{"location":"reference/libs/golang/shared/type-tools/docs/godoc/#index","title":"Index","text":"<ul> <li>func MapInterfaceToString(m map[string]interface{}) string</li> <li>func MapStringToString(m map[string]string) string</li> <li>func ParseBool(data string) (bool, error)</li> <li>func ParseDateWithFormat(date, format string) (time.Time, error)</li> <li>func ToFloat64(data interface{}) (float64, error)</li> <li>func ToString(data interface{}) (string, error)</li> </ul>"},{"location":"reference/libs/golang/shared/type-tools/docs/godoc/#func-mapinterfacetostring","title":"func MapInterfaceToString","text":"<pre><code>func MapInterfaceToString(m map[string]interface{}) string\n</code></pre> <p>MapInterfaceToString converts a map[string]interface{} to a sorted string</p> <p></p>"},{"location":"reference/libs/golang/shared/type-tools/docs/godoc/#func-mapstringtostring","title":"func MapStringToString","text":"<pre><code>func MapStringToString(m map[string]string) string\n</code></pre> <p>MapStringToString converts a map[string]string to a sorted string</p> <p></p>"},{"location":"reference/libs/golang/shared/type-tools/docs/godoc/#func-parsebool","title":"func ParseBool","text":"<pre><code>func ParseBool(data string) (bool, error)\n</code></pre> <p>ParseBool parses a boolean string</p> <p></p>"},{"location":"reference/libs/golang/shared/type-tools/docs/godoc/#func-parsedatewithformat","title":"func ParseDateWithFormat","text":"<pre><code>func ParseDateWithFormat(date, format string) (time.Time, error)\n</code></pre> <p>ParseDateWithFormat parses a date string with a given format</p> <p></p>"},{"location":"reference/libs/golang/shared/type-tools/docs/godoc/#func-tofloat64","title":"func ToFloat64","text":"<pre><code>func ToFloat64(data interface{}) (float64, error)\n</code></pre> <p>ToFloat64 converts various types of data to a float64</p> <p></p>"},{"location":"reference/libs/golang/shared/type-tools/docs/godoc/#func-tostring","title":"func ToString","text":"<pre><code>func ToString(data interface{}) (string, error)\n</code></pre> <p>ToString converts various types of data to a string</p> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/wrappers/core/resource-contract/","title":"resource-contract","text":"<p><code>resource-contract</code> is a Go library that defines a contract for resource wrappers, providing a standardized interface for initializing and retrieving clients. This library is designed to facilitate the integration and management of various resources within a consistent framework.</p>"},{"location":"reference/libs/golang/wrappers/core/resource-contract/#features","title":"Features","text":"<ul> <li>Define a standard interface for initializing resources.</li> <li>Retrieve the client instance for the resource.</li> </ul>"},{"location":"reference/libs/golang/wrappers/core/resource-contract/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/wrappers/core/resource-contract/#defining-a-resource-wrapper","title":"Defining a Resource Wrapper","text":"<p>To define a resource wrapper, implement the <code>Resource</code> interface provided by the <code>resource-contract</code> package. This interface requires two methods: <code>Init</code> and <code>GetClient</code>.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    resourceWrapper \"libs/golang/wrappers/core/resource-contract\"\n)\n\n// ExampleResource is an example implementation of the Resource interface\ntype ExampleResource struct {\n    client string\n}\n\n// Init initializes the ExampleResource\nfunc (r *ExampleResource) Init() error {\n    r.client = \"example_client\"\n    return nil\n}\n\n// GetClient returns the client instance for the ExampleResource\nfunc (r *ExampleResource) GetClient() interface{} {\n    return r.client\n}\n\nfunc main() {\n    var resource resourceWrapper.Resource = &amp;ExampleResource{}\n\n    err := resource.Init()\n    if err != nil {\n        log.Fatalf(\"Failed to initialize resource: %v\", err)\n    }\n\n    client := resource.GetClient()\n    if client == nil {\n        log.Fatalf(\"Failed to retrieve client\")\n    }\n\n    fmt.Println(\"Resource client:\", client)\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-contract/#interface-definition","title":"Interface Definition","text":"<p>The <code>Resource</code> interface defines the standard methods that all resource wrappers must implement.</p> <pre><code>package wrappersresourcecontract\n\n// Resource defines the interface that all resources should implement\ntype Resource interface {\n    Init() error\n    GetClient() interface{}\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-contract/#example-implementation-mongodb-wrapper","title":"Example Implementation: MongoDB Wrapper","text":"<p>Here is an example of how to implement the <code>Resource</code> interface for a MongoDB wrapper.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"libs/golang/wrappers/resources/mongo-wrapper/wrapper\"\n    resourceWrapper \"libs/golang/wrappers/core/resource-contract\"\n)\n\nfunc main() {\n    var resource resourceWrapper.Resource = mongowrapper.NewMongoDBWrapper()\n\n    err := resource.Init()\n    if err != nil {\n        log.Fatalf(\"Failed to initialize MongoDBWrapper: %v\", err)\n    }\n\n    client := resource.GetClient()\n    if client == nil {\n        log.Fatalf(\"MongoDB client is not initialized\")\n    }\n\n    fmt.Println(\"MongoDB client initialized successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-contract/#example-implementation-minio-wrapper","title":"Example Implementation: Minio Wrapper","text":"<p>Here is an example of how to implement the <code>Resource</code> interface for a Minio wrapper.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"miniowrapper\"\n    \"wrappersresourcecontract\"\n)\n\nfunc main() {\n    var resource wrappersresourcecontract.Resource = miniowrapper.NewMinioWrapper()\n\n    err := resource.Init()\n    if err != nil {\n        log.Fatalf(\"Failed to initialize MinioWrapper: %v\", err)\n    }\n\n    client := resource.GetClient()\n    if client == nil {\n        log.Fatalf(\"Minio client is not initialized\")\n    }\n\n    fmt.Println(\"Minio client initialized successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-contract/#example-implementation-rabbitmq-wrapper","title":"Example Implementation: RabbitMQ Wrapper","text":"<p>Here is an example of how to implement the <code>Resource</code> interface for a RabbitMQ wrapper.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"libs/golang/wrappers/resources/rabbitmq-wrapper/rabbitmqwrapper\"\n    resourceWrapper \"libs/golang/wrappers/core/resource-contract\"\n)\n\nfunc main() {\n    var resource resourceWrapper.Resource = rabbitmqwrapper.NewRabbitMQWrapper()\n\n    err := resource.Init()\n    if err != nil {\n        log.Fatalf(\"Failed to initialize RabbitMQWrapper: %v\", err)\n    }\n\n    client := resource.GetClient()\n    if client == nil {\n        log.Fatalf(\"RabbitMQ client is not initialized\")\n    }\n\n    fmt.Println(\"RabbitMQ client initialized successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-contract/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/wrappers/core/resource-contract/docs/godoc/#wrappersresourcecontract","title":"wrappersresourcecontract","text":"<pre><code>import \"libs/golang/wrappers/core/resource-contract\"\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-contract/docs/godoc/#index","title":"Index","text":"<ul> <li>type Resource</li> </ul>"},{"location":"reference/libs/golang/wrappers/core/resource-contract/docs/godoc/#type-resource","title":"type Resource","text":"<p>Resource defines the interface that all resources should implement</p> <pre><code>type Resource interface {\n    // Init initializes the resource and returns an error if any occurs.\n    Init() error\n\n    // GetClient returns the underlying client of the resource.\n    GetClient() interface{}\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/","title":"resource-mapping","text":"<p><code>resource-mapping</code> is a Go library that provides a centralized way to manage and access various resource wrappers. It allows you to register, initialize, and retrieve resource instances through a singleton instance, ensuring thread-safe operations and simplifying resource management in your applications.</p>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/#features","title":"Features","text":"<ul> <li>Centralized management of resource instances.</li> <li>Thread-safe registration and retrieval of resources.</li> <li>Easy initialization and access to resource clients.</li> </ul>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/wrappers/core/resource-mapping/#creating-a-resource-mapping","title":"Creating a Resource Mapping","text":"<p>To create a resource mapping, use the <code>NewResourceMapping</code> function which returns a singleton instance of the <code>Resources</code> struct.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    \"libs/golang/wrappers/core/resource-mapping\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    resources := resourcemapping.NewResourceMapping(ctx)\n\n    if resources == nil {\n        log.Fatal(\"Failed to create resource mapping instance\")\n    }\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/#registering-and-retrieving-resources","title":"Registering and Retrieving Resources","text":"<p>You can register resources using the <code>RegisterResource</code> method and retrieve them using the <code>GetResource</code> method. Resources must implement the <code>Resource</code> interface defined in the <code>resource-contract</code> package.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"libs/golang/wrappers/core/resource-mapping\"\n    resourceWrapper \"libs/golang/wrappers/core/resource-contract\"\n)\n\n// ExampleResource is a mock implementation of the Resource interface\ntype ExampleResource struct {\n    client string\n}\n\nfunc (r *ExampleResource) Init() error {\n    r.client = \"example_client\"\n    return nil\n}\n\nfunc (r *ExampleResource) GetClient() interface{} {\n    return r.client\n}\n\nfunc main() {\n    ctx := context.Background()\n    resources := resourcemapping.NewResourceMapping(ctx)\n    exampleResource := &amp;ExampleResource{}\n\n    // Register the resource\n    resources.RegisterResource(\"example\", exampleResource)\n\n    // Retrieve the resource\n    retrievedResource, err := resources.GetResource(\"example\")\n    if err != nil {\n        log.Fatalf(\"Failed to retrieve resource: %v\", err)\n    }\n\n    // Initialize the resource\n    err = retrievedResource.Init()\n    if err != nil {\n        log.Fatalf(\"Failed to initialize resource: %v\", err)\n    }\n\n    client := retrievedResource.GetClient()\n    if client == nil {\n        log.Fatalf(\"Failed to retrieve client\")\n    }\n\n    fmt.Println(\"Resource client:\", client)\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/#interface-definition","title":"Interface Definition","text":"<p>The <code>Resource</code> interface defines the standard methods that all resource wrappers must implement.</p> <pre><code>package wrappersresourcecontract\n\n// Resource defines the interface that all resources should implement\ntype Resource interface {\n    Init() error\n    GetClient() interface{}\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/#example-implementations","title":"Example Implementations","text":""},{"location":"reference/libs/golang/wrappers/core/resource-mapping/#mongodb-wrapper","title":"MongoDB Wrapper","text":"<p>Here is an example of how to implement the <code>Resource</code> interface for a MongoDB wrapper.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"libs/golang/wrappers/resources/mongo-wrapper/wrapper\"\n    resourceImpl \"libs/golang/wrappers/core/resource-contract\"\n)\n\nfunc main() {\n    var resource resourceImpl.Resource = mongowrapper.NewMongoDBWrapper()\n\n    err := resource.Init()\n    if err != nil {\n        log.Fatalf(\"Failed to initialize MongoDBWrapper: %v\", err)\n    }\n\n    client := resource.GetClient()\n    if client == nil {\n        log.Fatalf(\"MongoDB client is not initialized\")\n    }\n\n    fmt.Println(\"MongoDB client initialized successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/#minio-wrapper","title":"Minio Wrapper","text":"<p>Here is an example of how to implement the <code>Resource</code> interface for a Minio wrapper.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"libs/golang/wrappers/resources/minio-wrapper/wrapper\"\n    resourceImpl \"libs/golang/wrappers/core/resource-contract\"\n)\n\nfunc main() {\n    var resource resourceImpl.Resource = miniowrapper.NewMinioWrapper()\n\n    err := resource.Init()\n    if err != nil {\n        log.Fatalf(\"Failed to initialize MinioWrapper: %v\", err)\n    }\n\n    client := resource.GetClient()\n    if client == nil {\n        log.Fatalf(\"Minio client is not initialized\")\n    }\n\n    fmt.Println(\"Minio client initialized successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/#rabbitmq-wrapper","title":"RabbitMQ Wrapper","text":"<p>Here is an example of how to implement the <code>Resource</code> interface for a RabbitMQ wrapper.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"libs/golang/wrappers/resources/rabbitmq-wrapper/wrapper\"\n    resourceImpl \"libs/golang/wrappers/core/resource-contract\"\n)\n\nfunc main() {\n    var resource resourceImpl.Resource = rabbitmqwrapper.NewRabbitMQWrapper()\n\n    err := resource.Init()\n    if err != nil {\n        log.Fatalf(\"Failed to initialize RabbitMQWrapper: %v\", err)\n    }\n\n    client := resource.GetClient()\n    if client == nil {\n        log.Fatalf(\"RabbitMQ client is not initialized\")\n    }\n\n    fmt.Println(\"RabbitMQ client initialized successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/#running-tests","title":"Running Tests","text":"<p>To run the test suite for the <code>resource-mapping</code> library, execute the following command:</p> <pre><code>npx nx test libs-golang-wrappers-core-resource-mapping\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/wrappers/core/resource-mapping/docs/godoc/#resourcemapping","title":"resourcemapping","text":"<pre><code>import \"libs/golang/wrappers/core/resource-mapping/mapping\"\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/docs/godoc/#index","title":"Index","text":"<ul> <li>type FailingMockResource</li> <li>func (f *FailingMockResource) GetClient() interface{}</li> <li>func (f *FailingMockResource) Init() error</li> <li>type MockResource</li> <li>func (m *MockResource) GetClient() interface{}</li> <li>func (m *MockResource) Init() error</li> <li>type Resources</li> <li>func NewResourceMapping() *Resources</li> <li>func (r *Resources) GetResource(key string) (resourceImpl.Resource, error)</li> <li>func (r *Resources) RegisterResource(key string, resource resourceImpl.Resource)</li> </ul>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/docs/godoc/#type-failingmockresource","title":"type FailingMockResource","text":"<pre><code>type FailingMockResource struct{}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/docs/godoc/#func-failingmockresource-getclient","title":"func (*FailingMockResource) GetClient","text":"<pre><code>func (f *FailingMockResource) GetClient() interface{}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/docs/godoc/#func-failingmockresource-init","title":"func (*FailingMockResource) Init","text":"<pre><code>func (f *FailingMockResource) Init() error\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/docs/godoc/#type-mockresource","title":"type MockResource","text":"<pre><code>type MockResource struct {\n    // contains filtered or unexported fields\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/docs/godoc/#func-mockresource-getclient","title":"func (*MockResource) GetClient","text":"<pre><code>func (m *MockResource) GetClient() interface{}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/docs/godoc/#func-mockresource-init","title":"func (*MockResource) Init","text":"<pre><code>func (m *MockResource) Init() error\n</code></pre>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/docs/godoc/#type-resources","title":"type Resources","text":"<p>Resources struct holds the initialized resources</p> <pre><code>type Resources struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/docs/godoc/#func-newresourcemapping","title":"func NewResourceMapping","text":"<pre><code>func NewResourceMapping() *Resources\n</code></pre> <p>NewResourceMapping creates a singleton instance of Resources</p> <p></p>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/docs/godoc/#func-resources-getresource","title":"func (*Resources) GetResource","text":"<pre><code>func (r *Resources) GetResource(key string) (resourceImpl.Resource, error)\n</code></pre> <p>GetResource retrieves a resource by key</p> <p></p>"},{"location":"reference/libs/golang/wrappers/core/resource-mapping/docs/godoc/#func-resources-registerresource","title":"func (*Resources) RegisterResource","text":"<pre><code>func (r *Resources) RegisterResource(key string, resource resourceImpl.Resource)\n</code></pre> <p>RegisterResource registers a resource with a given key</p> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/","title":"minio-wrapper","text":"<p><code>minio-wrapper</code> is a Go library that provides a wrapper around a Minio client with an interface for creating and managing Minio connections. This library simplifies the initialization of Minio clients using environment variables and provides methods to retrieve the client.</p>"},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/#features","title":"Features","text":"<ul> <li>Initialize a Minio client using environment variables</li> <li>Retrieve the Minio client instance</li> </ul>"},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/#initializing-a-minio-client","title":"Initializing a Minio Client","text":"<p>The <code>MinioWrapper</code> struct provides an <code>Init</code> method to initialize a Minio client using configuration parameters from environment variables.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"libs/golang/wrappers/resources/minio-wrapper/miniowrapper\"\n)\n\nfunc main() {\n    wrapper := miniowrapper.NewMinioWrapper()\n\n    err := wrapper.Init()\n    if err != nil {\n        log.Fatalf(\"Failed to initialize Minio client: %v\", err)\n    }\n\n    client := wrapper.GetClient()\n    if client == nil {\n        log.Fatalf(\"Failed to retrieve Minio client\")\n    }\n\n    fmt.Println(\"Minio client initialized and retrieved successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/#retrieving-the-minio-client","title":"Retrieving the Minio Client","text":"<p>The <code>MinioWrapper</code> provides a method to retrieve the initialized Minio client.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"libs/golang/wrappers/resources/minio-wrapper/miniowrapper\"\n)\n\nfunc main() {\n    wrapper := miniowrapper.NewMinioWrapper()\n\n    err := wrapper.Init()\n    if err != nil {\n        log.Fatalf(\"Failed to initialize Minio client: %v\", err)\n    }\n\n    client := wrapper.GetClient()\n    if client == nil {\n        log.Fatalf(\"Failed to retrieve Minio client\")\n    }\n\n    fmt.Println(\"Minio client retrieved successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/#environment-variables","title":"Environment Variables","text":"<p>The <code>MinioWrapper</code> uses the following environment variables to configure the Minio client:</p> <ul> <li><code>MINIO_ENDPOINT</code>: The endpoint URL for the Minio server</li> <li><code>MINIO_ACCESS_KEY</code>: The access key for authentication</li> <li><code>MINIO_SECRET_KEY</code>: The secret key for authentication</li> <li><code>MINIO_USE_SSL</code>: Set to <code>true</code> to use SSL/TLS, <code>false</code> otherwise</li> </ul> <p>Ensure these variables are set in your environment before initializing the <code>MinioWrapper</code>.</p>"},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/#testing","title":"Testing","text":"<p>To run the tests for the <code>miniowrapper</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-wrappers-resources-minio-wrapper\n</code></pre>"},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/#example","title":"Example","text":"<p>Here's an example of how to use the <code>minio-wrapper</code> library:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"libs/golang/wrappers/resources/minio-wrapper/miniowrapper\"\n)\n\nfunc main() {\n    os.Setenv(\"MINIO_ENDPOINT\", \"localhost:9000\")\n    os.Setenv(\"MINIO_ACCESS_KEY\", \"minioaccesskey\")\n    os.Setenv(\"MINIO_SECRET_KEY\", \"miniosecretkey\")\n    os.Setenv(\"MINIO_USE_SSL\", \"false\")\n\n    wrapper := miniowrapper.NewMinioWrapper()\n\n    err := wrapper.Init()\n    if err != nil {\n        log.Fatalf(\"Failed to initialize Minio client: %v\", err)\n    }\n\n    client := wrapper.GetClient()\n    if client == nil {\n        log.Fatalf(\"Failed to retrieve Minio client\")\n    }\n\n    fmt.Println(\"Minio client initialized and retrieved successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/docs/godoc/#miniowrapper","title":"miniowrapper","text":"<pre><code>import \"libs/golang/wrappers/resources/minio-wrapper/wrapper\"\n</code></pre>"},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/docs/godoc/#index","title":"Index","text":"<ul> <li>type ClientFactory</li> <li>type DefaultClientFactory</li> <li>func (f *DefaultClientFactory) NewClient(config gominio.Config) (*gominio.Client, error)</li> <li>type MinioWrapper</li> <li>func NewMinioWrapper() *MinioWrapper</li> <li>func (m *MinioWrapper) GetClient() interface{}</li> <li>func (m *MinioWrapper) Init() error</li> </ul>"},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/docs/godoc/#type-clientfactory","title":"type ClientFactory","text":"<p>ClientFactory defines an interface for creating new Minio clients.</p> <pre><code>type ClientFactory interface {\n    // NewClient creates a new Minio client with the provided configuration.\n    // It returns the client and an error if any occurred during the connection.\n    NewClient(config gominio.Config) (*gominio.Client, error)\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/docs/godoc/#type-defaultclientfactory","title":"type DefaultClientFactory","text":"<p>DefaultClientFactory is a default implementation of the ClientFactory interface.</p> <pre><code>type DefaultClientFactory struct{}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/docs/godoc/#func-defaultclientfactory-newclient","title":"func (*DefaultClientFactory) NewClient","text":"<pre><code>func (f *DefaultClientFactory) NewClient(config gominio.Config) (*gominio.Client, error)\n</code></pre> <p>NewClient creates a new Minio client with the provided configuration using the default implementation.</p> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/docs/godoc/#type-miniowrapper","title":"type MinioWrapper","text":"<p>MinioWrapper wraps a Minio client and provides initialization and retrieval methods.</p> <pre><code>type MinioWrapper struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/docs/godoc/#func-newminiowrapper","title":"func NewMinioWrapper","text":"<pre><code>func NewMinioWrapper() *MinioWrapper\n</code></pre> <p>NewMinioWrapper creates a new MinioWrapper with the default client factory.</p> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/docs/godoc/#func-miniowrapper-getclient","title":"func (*MinioWrapper) GetClient","text":"<pre><code>func (m *MinioWrapper) GetClient() interface{}\n</code></pre> <p>GetClient returns the Minio client.</p> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/minio-wrapper/docs/godoc/#func-miniowrapper-init","title":"func (*MinioWrapper) Init","text":"<pre><code>func (m *MinioWrapper) Init() error\n</code></pre> <p>Init initializes the Minio client using environment variables for configuration. It returns an error if the client could not be created.</p> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/","title":"mongo-wrapper","text":"<p><code>mongo-wrapper</code> is a Go library that provides a wrapper around a MongoDB client with an interface for creating and managing MongoDB connections. This library simplifies the initialization of MongoDB clients using environment variables and provides methods to retrieve the client.</p>"},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/#features","title":"Features","text":"<ul> <li>Initialize a MongoDB client using environment variables</li> <li>Retrieve the MongoDB client instance</li> </ul>"},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/#initializing-a-mongodb-client","title":"Initializing a MongoDB Client","text":"<p>The <code>MongoDBWrapper</code> struct provides an <code>Init</code> method to initialize a MongoDB client using configuration parameters from environment variables.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"libs/golang/wrappers/resources/mongo-wrapper/wrapper\"\n)\n\nfunc main() {\n    wrapper := mongowrapper.NewMongoDBWrapper()\n\n    err := wrapper.Init()\n    if err != nil {\n        log.Fatalf(\"Failed to initialize MongoDB client: %v\", err)\n    }\n\n    client := wrapper.GetClient()\n    if client == nil {\n        log.Fatalf(\"Failed to retrieve MongoDB client\")\n    }\n\n    fmt.Println(\"MongoDB client initialized and retrieved successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/#retrieving-the-mongodb-client","title":"Retrieving the MongoDB Client","text":"<p>The <code>MongoDBWrapper</code> provides a method to retrieve the initialized MongoDB client.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"libs/golang/wrappers/resources/mongo-wrapper/wrapper\"\n)\n\nfunc main() {\n    wrapper := mongowrapper.NewMongoDBWrapper()\n\n    err := wrapper.Init()\n    if err != nil {\n        log.Fatalf(\"Failed to initialize MongoDB client: %v\", err)\n    }\n\n    client := wrapper.GetClient()\n    if client == nil {\n        log.Fatalf(\"Failed to retrieve MongoDB client\")\n    }\n\n    fmt.Println(\"MongoDB client retrieved successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/#environment-variables","title":"Environment Variables","text":"<p>The <code>MongoDBWrapper</code> uses the following environment variables to configure the MongoDB client:</p> <ul> <li><code>MONGODB_USER</code>: The username for authentication</li> <li><code>MONGODB_PASSWORD</code>: The password for authentication</li> <li><code>MONGODB_HOST</code>: The host of the MongoDB instance</li> <li><code>MONGODB_PORT</code>: The port of the MongoDB instance</li> <li><code>MONGODB_DBNAME</code>: The name of the database to connect to</li> </ul> <p>Ensure these variables are set in your environment before initializing the <code>MongoDBWrapper</code>.</p>"},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/#testing","title":"Testing","text":"<p>To run the tests for the <code>mongowrapper</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-wrappers-resources-mongo-wrapper\n</code></pre>"},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/#example","title":"Example","text":"<p>Here's an example of how to use the <code>mongowrapper</code> library:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"libs/golang/wrappers/resources/mongo-wrapper/wrapper\"\n)\n\nfunc main() {\n    os.Setenv(\"MONGODB_USER\", \"testuser\")\n    os.Setenv(\"MONGODB_PASSWORD\", \"testpassword\")\n    os.Setenv(\"MONGODB_HOST\", \"localhost\")\n    os.Setenv(\"MONGODB_PORT\", \"27017\")\n    os.Setenv(\"MONGODB_DBNAME\", \"testdb\")\n\n    wrapper := mongowrapper.NewMongoDBWrapper()\n\n    err := wrapper.Init()\n    if err != nil {\n        log.Fatalf(\"Failed to initialize MongoDB client: %v\", err)\n    }\n\n    client := wrapper.GetClient()\n    if client == nil {\n        log.Fatalf(\"Failed to retrieve MongoDB client\")\n    }\n\n    fmt.Println(\"MongoDB client initialized and retrieved successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/docs/godoc/#mongowrapper","title":"mongowrapper","text":"<pre><code>import \"libs/golang/wrappers/resources/mongo-wrapper/wrapper\"\n</code></pre>"},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/docs/godoc/#index","title":"Index","text":"<ul> <li>type ClientFactory</li> <li>type DefaultClientFactory</li> <li>func (f *DefaultClientFactory) NewClient(config gomongodb.Config) (*gomongodb.Client, error)</li> <li>type MongoDBWrapper</li> <li>func NewMongoDBWrapper() *MongoDBWrapper</li> <li>func (m *MongoDBWrapper) GetClient() interface{}</li> <li>func (m *MongoDBWrapper) Init() error</li> </ul>"},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/docs/godoc/#type-clientfactory","title":"type ClientFactory","text":"<p>ClientFactory defines an interface for creating new MongoDB clients.</p> <pre><code>type ClientFactory interface {\n    // NewClient creates a new MongoDB client with the provided configuration.\n    // It returns the client and an error if any occurred during the connection.\n    NewClient(config gomongodb.Config) (*gomongodb.Client, error)\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/docs/godoc/#type-defaultclientfactory","title":"type DefaultClientFactory","text":"<p>DefaultClientFactory is a default implementation of the ClientFactory interface.</p> <pre><code>type DefaultClientFactory struct{}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/docs/godoc/#func-defaultclientfactory-newclient","title":"func (*DefaultClientFactory) NewClient","text":"<pre><code>func (f *DefaultClientFactory) NewClient(config gomongodb.Config) (*gomongodb.Client, error)\n</code></pre> <p>NewClient creates a new MongoDB client with the provided configuration using the default implementation.</p> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/docs/godoc/#type-mongodbwrapper","title":"type MongoDBWrapper","text":"<p>MongoDBWrapper wraps a MongoDB client and provides initialization and retrieval methods.</p> <pre><code>type MongoDBWrapper struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/docs/godoc/#func-newmongodbwrapper","title":"func NewMongoDBWrapper","text":"<pre><code>func NewMongoDBWrapper() *MongoDBWrapper\n</code></pre> <p>NewMongoDBWrapper creates a new MongoDBWrapper with the default client factory.</p> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/docs/godoc/#func-mongodbwrapper-getclient","title":"func (*MongoDBWrapper) GetClient","text":"<pre><code>func (m *MongoDBWrapper) GetClient() interface{}\n</code></pre> <p>GetClient returns the MongoDB client.</p> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/mongo-wrapper/docs/godoc/#func-mongodbwrapper-init","title":"func (*MongoDBWrapper) Init","text":"<pre><code>func (m *MongoDBWrapper) Init() error\n</code></pre> <p>Init initializes the MongoDB client using environment variables for configuration. It returns an error if the client could not be created.</p> <p>Generated by gomarkdoc</p>"},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/","title":"rabbitmq-wrapper","text":"<p><code>rabbitmq-wrapper</code> is a Go library that provides a wrapper around a RabbitMQ client with an interface for creating and managing RabbitMQ connections. This library simplifies the initialization of RabbitMQ clients using environment variables and provides methods to retrieve the client.</p>"},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/#features","title":"Features","text":"<ul> <li>Initialize a RabbitMQ client using environment variables</li> <li>Retrieve the RabbitMQ client instance</li> </ul>"},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/#usage","title":"Usage","text":""},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/#initializing-a-rabbitmq-client","title":"Initializing a RabbitMQ Client","text":"<p>The <code>RabbitMQWrapper</code> struct provides an <code>Init</code> method to initialize a RabbitMQ client using configuration parameters from environment variables.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"libs/golang/wrappers/resources/rabbitmq-wrapper/rabbitmqwrapper\"\n)\n\nfunc main() {\n    wrapper := rabbitmqwrapper.NewRabbitMQWrapper()\n\n    err := wrapper.Init()\n    if err != nil {\n        log.Fatalf(\"Failed to initialize RabbitMQ client: %v\", err)\n    }\n\n    client := wrapper.GetClient()\n    if client == nil {\n        log.Fatalf(\"Failed to retrieve RabbitMQ client\")\n    }\n\n    fmt.Println(\"RabbitMQ client initialized and retrieved successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/#retrieving-the-rabbitmq-client","title":"Retrieving the RabbitMQ Client","text":"<p>The <code>RabbitMQWrapper</code> provides a method to retrieve the initialized RabbitMQ client.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"libs/golang/wrappers/resources/rabbitmq-wrapper/rabbitmqwrapper\"\n)\n\nfunc main() {\n    wrapper := rabbitmqwrapper.NewRabbitMQWrapper()\n\n    err := wrapper.Init()\n    if err != nil {\n        log.Fatalf(\"Failed to initialize RabbitMQ client: %v\", err)\n    }\n\n    client := wrapper.GetClient()\n    if client == nil {\n        log.Fatalf(\"Failed to retrieve RabbitMQ client\")\n    }\n\n    fmt.Println(\"RabbitMQ client retrieved successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/#environment-variables","title":"Environment Variables","text":"<p>The <code>RabbitMQWrapper</code> uses the following environment variables to configure the RabbitMQ client:</p> <ul> <li><code>RABBITMQ_USER</code>: The username for authentication</li> <li><code>RABBITMQ_PASSWORD</code>: The password for authentication</li> <li><code>RABBITMQ_HOST</code>: The host of the RabbitMQ instance</li> <li><code>RABBITMQ_PORT</code>: The port of the RabbitMQ instance</li> <li><code>RABBITMQ_PROTOCOL</code>: The protocol to use for the connection (e.g., \"amqp\")</li> <li><code>RABBITMQ_EXCHANGE_NAME</code>: The name of the RabbitMQ exchange to use</li> <li><code>RABBITMQ_EXCHANGE_TYPE</code>: The type of the RabbitMQ exchange (e.g., \"direct\", \"fanout\")</li> </ul> <p>Ensure these variables are set in your environment before initializing the <code>RabbitMQWrapper</code>.</p>"},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/#testing","title":"Testing","text":"<p>To run the tests for the <code>rabbitmqwrapper</code> package, use the following command:</p> <pre><code>npx nx test libs-golang-wrappers-resources-rabbitmq-wrapper\n</code></pre>"},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/#example","title":"Example","text":"<p>Here's an example of how to use the <code>rabbitmqwrapper</code> library:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"libs/golang/wrappers/resources/rabbitmq-wrapper/rabbitmqwrapper\"\n)\n\nfunc main() {\n    os.Setenv(\"RABBITMQ_USER\", \"testuser\")\n    os.Setenv(\"RABBITMQ_PASSWORD\", \"testpassword\")\n    os.Setenv(\"RABBITMQ_HOST\", \"localhost\")\n    os.Setenv(\"RABBITMQ_PORT\", \"5672\")\n    os.Setenv(\"RABBITMQ_PROTOCOL\", \"amqp\")\n    os.Setenv(\"RABBITMQ_EXCHANGE_NAME\", \"testexchange\")\n    os.Setenv(\"RABBITMQ_EXCHANGE_TYPE\", \"direct\")\n\n    wrapper := rabbitmqwrapper.NewRabbitMQWrapper()\n\n    err := wrapper.Init()\n    if err != nil {\n        log.Fatalf(\"Failed to initialize RabbitMQ client: %v\", err)\n    }\n\n    client := wrapper.GetClient()\n    if client == nil {\n        log.Fatalf(\"Failed to retrieve RabbitMQ client\")\n    }\n\n    fmt.Println(\"RabbitMQ client initialized and retrieved successfully\")\n}\n</code></pre>"},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/docs/godoc/","title":"Godoc","text":""},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/docs/godoc/#rabbitmqwrapper","title":"rabbitmqwrapper","text":"<pre><code>import \"libs/golang/wrappers/resources/rabbitmq-wrapper/wrapper\"\n</code></pre>"},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/docs/godoc/#index","title":"Index","text":"<ul> <li>type ClientFactory</li> <li>type DefaultClientFactory</li> <li>func (f *DefaultClientFactory) NewClient(config gorabbitmq.Config) (*gorabbitmq.Client, error)</li> <li>type RabbitMQWrapper</li> <li>func NewRabbitMQWrapper() *RabbitMQWrapper</li> <li>func (r *RabbitMQWrapper) GetClient() interface{}</li> <li>func (r *RabbitMQWrapper) Init() error</li> </ul>"},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/docs/godoc/#type-clientfactory","title":"type ClientFactory","text":"<p>ClientFactory defines an interface for creating new RabbitMQ clients.</p> <pre><code>type ClientFactory interface {\n    // NewClient creates a new RabbitMQ client with the provided configuration.\n    // It returns the client and an error if any occurred during the connection.\n    NewClient(config gorabbitmq.Config) (*gorabbitmq.Client, error)\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/docs/godoc/#type-defaultclientfactory","title":"type DefaultClientFactory","text":"<p>DefaultClientFactory is a default implementation of the ClientFactory interface.</p> <pre><code>type DefaultClientFactory struct{}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/docs/godoc/#func-defaultclientfactory-newclient","title":"func (*DefaultClientFactory) NewClient","text":"<pre><code>func (f *DefaultClientFactory) NewClient(config gorabbitmq.Config) (*gorabbitmq.Client, error)\n</code></pre> <p>NewClient creates a new RabbitMQ client with the provided configuration using the default implementation.</p> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/docs/godoc/#type-rabbitmqwrapper","title":"type RabbitMQWrapper","text":"<p>RabbitMQWrapper wraps a RabbitMQ client and provides initialization and retrieval methods.</p> <pre><code>type RabbitMQWrapper struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/docs/godoc/#func-newrabbitmqwrapper","title":"func NewRabbitMQWrapper","text":"<pre><code>func NewRabbitMQWrapper() *RabbitMQWrapper\n</code></pre> <p>NewRabbitMQWrapper creates a new RabbitMQWrapper with the default client factory.</p> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/docs/godoc/#func-rabbitmqwrapper-getclient","title":"func (*RabbitMQWrapper) GetClient","text":"<pre><code>func (r *RabbitMQWrapper) GetClient() interface{}\n</code></pre> <p>GetClient returns the RabbitMQ client.</p> <p></p>"},{"location":"reference/libs/golang/wrappers/resources/rabbitmq-wrapper/docs/godoc/#func-rabbitmqwrapper-init","title":"func (*RabbitMQWrapper) Init","text":"<pre><code>func (r *RabbitMQWrapper) Init() error\n</code></pre> <p>Init initializes the RabbitMQ client using environment variables for configuration. It returns an error if the client could not be created.</p> <p>Generated by gomarkdoc</p>"},{"location":"reference/services/shared/config-vault/","title":"Config Vault","text":"<p>Config Vault is a Go-based application designed for managing configurations and health checks.</p>"},{"location":"reference/services/shared/config-vault/#features","title":"Features","text":"<ul> <li>Health check endpoint</li> <li>CRUD operations for configurations</li> <li>Dynamic routing for service and provider-based queries</li> </ul>"},{"location":"reference/services/shared/config-vault/#endpoints","title":"Endpoints","text":""},{"location":"reference/services/shared/config-vault/#health-check","title":"Health Check","text":"<ul> <li>GET /healthz</li> <li>Returns the health status of the application.</li> </ul>"},{"location":"reference/services/shared/config-vault/#configuration-management","title":"Configuration Management","text":"<ul> <li>POST /config</li> <li>Creates a new configuration.</li> <li> <p>Body: JSON object with configuration details.</p> </li> <li> <p>PUT /config</p> </li> <li>Updates an existing configuration.</li> <li> <p>Body: JSON object with updated configuration details.</p> </li> <li> <p>GET /config</p> </li> <li> <p>Lists all configurations.</p> </li> <li> <p>GET /config/{id}</p> </li> <li> <p>Retrieves a configuration by its ID.</p> </li> <li> <p>DELETE /config/{id}</p> </li> <li> <p>Deletes a configuration by its ID.</p> </li> <li> <p>GET /config/provider/{provider}/service/{service}</p> </li> <li> <p>Lists configurations by service and provider.</p> </li> <li> <p>GET /config/provider/{provider}/source/{source}</p> </li> <li> <p>Lists configurations by source and provider.</p> </li> <li> <p>GET /config/provider/{provider}/service/{service}/active/{active}</p> </li> <li> <p>Lists configurations by service, provider, and active status.</p> </li> <li> <p>GET /config/provider/{provider}/service/{service}/source/{source}</p> </li> <li> <p>Lists configurations by service, source, and provider.</p> </li> <li> <p>GET /config/provider/{provider}/dependencies/service/{service}/source/{source}</p> </li> <li>Lists configurations by provider and dependencies.</li> </ul>"},{"location":"reference/services/shared/config-vault/#building-and-deploying","title":"Building and Deploying","text":"<p>The application can be built and deployed using the provided Nx targets. The following targets are defined:</p> <ul> <li>serve: Runs the Go application.</li> <li>test: Runs the tests.</li> <li>lint: Lints the code.</li> <li>tidy: Tidies the Go modules.</li> <li>godoc: Generates Go documentation.</li> <li>wire: Runs Google Wire for dependency injection.</li> <li>build: Builds the Go application for a Linux environment.</li> <li>image: Builds the Docker image.</li> </ul> <p>Example command to build the Docker image: <pre><code>npx nx image services-shared-config-vault\n</code></pre></p>"},{"location":"reference/services/shared/config-vault/#docker-compose-configuration","title":"Docker Compose Configuration","text":""},{"location":"reference/services/shared/config-vault/#config-vault_1","title":"Config Vault","text":"<ul> <li>Image: fabiocaffarello/config-vault:latest</li> <li>Environment Variables:</li> <li><code>MONGODB_USER</code>: MongoDB username</li> <li><code>MONGODB_PASSWORD</code>: MongoDB password</li> <li><code>MONGODB_HOST</code>: MongoDB host</li> <li><code>MONGODB_PORT</code>: MongoDB port</li> <li><code>MONGODB_DBNAME</code>: MongoDB database name</li> <li>Ports: 8000:8000</li> <li>Healthcheck: Checks Config Vault health by calling the health endpoint.</li> </ul>"},{"location":"reference/services/shared/config-vault/docs/godoc/","title":"Godoc","text":""},{"location":"reference/services/shared/config-vault/docs/godoc/#server","title":"server","text":"<pre><code>import \"services/shared/config-vault/cmd/server\"\n</code></pre>"},{"location":"reference/services/shared/config-vault/docs/godoc/#index","title":"Index","text":"<ul> <li>func NewWebServiceConfigHandler(client *mongo.Client, database string) *handlers.WebConfigHandler</li> </ul>"},{"location":"reference/services/shared/config-vault/docs/godoc/#func-newwebserviceconfighandler","title":"func NewWebServiceConfigHandler","text":"<pre><code>func NewWebServiceConfigHandler(client *mongo.Client, database string) *handlers.WebConfigHandler\n</code></pre> <p>Generated by gomarkdoc</p>"}]}